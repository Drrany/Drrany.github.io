

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;dark&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200909-100832-0414.png">
  <link rel="icon" type="image/png" href="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200909-100832-0414.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="取乎其下，则无所得矣。">
  <meta name="author" content="Drrany">
  <meta name="keywords" content="">
  <title>最短路径算法总结和LeetCode题目实践 / Drrany</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/atom-one-dark.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="Drrany" type="application/atom+xml">
</head>


<body>
  <header style="height: 100vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Drrany</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://gitee.com/Drrany/picbed/raw/master/images_blog/20210129-172236-0842.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-29 15:43" pubdate>
        2021年1月29日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      60
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">最短路径算法总结和LeetCode题目实践</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年2月10日 上午
                
              </p>
            
            <div class="markdown-body" id="post-body">
              <blockquote>
<p>常见的最短路径算法总结。</p>
</blockquote>
<a id="more"></a>

<h1 id="最短路径算法总结和-LeetCode-题目实践"><a href="#最短路径算法总结和-LeetCode-题目实践" class="headerlink" title="最短路径算法总结和 LeetCode 题目实践"></a>最短路径算法总结和 LeetCode 题目实践</h1><p>最近复习到了图相关，总结了最短路径问题的几个常用算法（Dijsktra 算法、Floyd 算法、Bellman-Ford 算法、SPFA 算法）。给出了具体题目实现。</p>
<p>给定图 G(V,E)，共有 n 个顶点：</p>
<h2 id="Dijsktra-算法"><a href="#Dijsktra-算法" class="headerlink" title="Dijsktra 算法"></a>Dijsktra 算法</h2><p>通常用于计算单源最短路径问题，即给定源点<code>src</code>，计算其他每个顶点到源点的最短距离。（注意：Dijsktra 不能解决边权有负值的情况）</p>
<p><strong>基本思想</strong>：设置一个顶点集合 S，存放已找到最短路径的顶点，每次从 V-S 集合中找距离源点距离最小的点，假设为<code>u</code>，将其加入集合 S。再次遍历 V-S 集合中的点，设为<code>v</code>，看是否能对边<code>(u,v)</code>进行松弛操作(<code>dist[u]+G[u][v]&lt;dist[v]</code>)。</p>
<p><strong>伪代码</strong>：</p>
<pre><code class="hljs c++"><span class="hljs-comment">// 设置的数据结构：</span>
<span class="hljs-keyword">bool</span> visited[n]; <span class="hljs-comment">// visited[i]=true表示顶点i已经加入集合S</span>
<span class="hljs-keyword">int</span> dist[n];	 <span class="hljs-comment">// dist[i]表示顶点i距离源点的最短距离</span>
<span class="hljs-keyword">int</span> pre[n];	     <span class="hljs-comment">// 到达pre[i]的最短路径上，i的前一个顶点</span>
遍历n次：
    找出V-S中距离源点最近的点，记为u
    若不存在，说明G不是连通图
    visited[u]=<span class="hljs-literal">true</span>
    遍历V-S中所有点v
    	若dist[u]+G[u][v]&lt;dist[v]：
    		更新dist[v]和pre[v]</code></pre>
<p>例：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/network-delay-time/">LeetCode-743.网络延迟时间</a></p>
<ul>
<li><p>思路：计算源点到其他所有点所需的时间，记录在数组 dist[]中，返回 dist[]中的最大值，即延迟时间</p>
<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;times, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
        <span class="hljs-comment">// 将times转换为邻接矩阵G</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">G</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, INT32_MAX))</span></span>;
        <span class="hljs-keyword">int</span> len = times.<span class="hljs-built_in">size</span>(), ui, vi, wi;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;
            ui = times[i][<span class="hljs-number">0</span>], vi = times[i][<span class="hljs-number">1</span>], wi = times[i][<span class="hljs-number">2</span>];
            G[ui][vi] = wi;
        &#125;

        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT32_MAX)</span></span>; <span class="hljs-comment">// 到源点的距离</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// 是否加入集合S</span>
        dist[k] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 遍历n次</span>
            <span class="hljs-comment">// 找出集合V-S中距离源点最近的</span>
            <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, minDist = INT32_MAX;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;
                <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;
                    u = j;
                    minDist = dist[j];
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;   <span class="hljs-comment">// 若未找到，返回-1</span>
            visited[u] = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 将u加入集合S</span>
            <span class="hljs-comment">// 用顶点u更新V-S中其他顶点的最短距离</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) &#123;
                <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INT32_MAX)
                    dist[v] = <span class="hljs-built_in">min</span>(dist[v], dist[u] + G[u][v]);
            &#125;

        &#125;
        <span class="hljs-keyword">return</span> *max_element(dist.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, dist.<span class="hljs-built_in">end</span>());
    &#125;
&#125;;</code></pre></li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">LeetCode-787. K 站中转内最便宜的航班</a></p>
<ul>
<li><p>思路：使用优先队列+Dijsktra 算法。记录到达每个结点(城市)处的中转次数和花费，优先操作花费最少的结点。</p>
   <pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">City</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> index; <span class="hljs-comment">// 城市编号</span>
    <span class="hljs-keyword">int</span> cost;  <span class="hljs-comment">// 花费</span>
    <span class="hljs-keyword">int</span> hop;   <span class="hljs-comment">// 到达该城市的中转次数</span>
City(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> h) &#123;
    index = i, cost = c, hop = h;
&#125;

    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> City &amp;a, <span class="hljs-keyword">const</span> City &amp;b) &#123;
        <span class="hljs-keyword">return</span> a.cost &gt; b.cost;
    &#125;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;flights, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dst, <span class="hljs-keyword">int</span> K)</span> </span>&#123;
        <span class="hljs-comment">// 将flights转换为邻接矩阵</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">G</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, INT32_MAX))</span></span>;
        <span class="hljs-keyword">int</span> len = flights.<span class="hljs-built_in">size</span>(), ui, vi, wi;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;
            ui = flights[i][<span class="hljs-number">0</span>], vi = flights[i][<span class="hljs-number">1</span>], wi = flights[i][<span class="hljs-number">2</span>];
            G[ui][vi] = wi;
        &#125;

        <span class="hljs-comment">// 创建优先队列，花费少的结点优先</span>
        <span class="hljs-built_in">priority_queue</span>&lt;City&gt; pq;
        pq.push(City(src, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));
        <span class="hljs-keyword">while</span> (!pq.empty()) &#123;
            City t = pq.top();
            pq.pop();
            <span class="hljs-keyword">if</span> (t.hop &gt; K + <span class="hljs-number">1</span>) <span class="hljs-comment">// k站中转，hop最大可以等于K+1</span>
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">int</span> u = t.index, c = t.cost, h = t.hop;
            <span class="hljs-keyword">if</span> (u == dst)   <span class="hljs-comment">// 若能到达目的地，则一定是最优花费的</span>
                <span class="hljs-keyword">return</span> c;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; ++v) &#123;
                <span class="hljs-keyword">if</span> (G[u][v] != INT32_MAX)
                    pq.push(City(v, G[u][v] + c, h + <span class="hljs-number">1</span>));
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
&#125;;
</code></pre>


</li>
</ul>
</li>
</ol>
<h3 id="Dijsktra-算法-DFS"><a href="#Dijsktra-算法-DFS" class="headerlink" title="Dijsktra 算法+DFS"></a>Dijsktra 算法+DFS</h3><p>上面两道题都没有要求输出具体的最短路径，所以没有使用 pre 数组。有两种稍微复杂的情况如下：</p>
<ol>
<li>源点到某个点的最短路径不止一条</li>
<li>不光要求从源点到其他点的距离最短，还有其他最优要求（e.g. 每个点有一个属性值，要求总属性值最大/小）</li>
</ol>
<p>第一个问题可以通过将 pre 数组修改为<code>vector&lt;vecotr&lt;int&gt; &gt;pre</code>，然后对<code>pre</code>进行 DFS 得到每条路径。</p>
<p>第二个问题，如果最优要求比较简单，可以直接在原有 Dijsktra 算法上修改，如果比较麻烦，可以先求出所有最短路径，再通过 DFS 对每条路径的属性进行比较，得到要求解。</p>
<p>例：<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">PAT-1003.Emergency</a></p>
<ul>
<li><p>思路：该题中不仅要求距离最短，还要求所有最短路径中，输出救援队人数最多的那条（也就是路径经过的所有城市点权相加）</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> maxSum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> ansNum = <span class="hljs-number">0</span>;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; curPath;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; pre, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; w, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> src)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (u == src) &#123;
        ansNum++;
        curPath.push_back(u);
        <span class="hljs-comment">// 计算救援队总人数</span>
        <span class="hljs-keyword">int</span> len = curPath.<span class="hljs-built_in">size</span>(), curSum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)
            curSum += w[curPath[i]];
        maxSum = <span class="hljs-built_in">max</span>(maxSum, curSum);
        curPath.pop_back();
        <span class="hljs-keyword">return</span>;
    &#125;
    curPath.push_back(u);
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; last = pre[u];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; last.<span class="hljs-built_in">size</span>(); ++i)
        dfs(pre, w, last[i], src);

    curPath.pop_back();

&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> n, m, src, dst;
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; src &gt;&gt; dst;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(n)</span></span>;   <span class="hljs-comment">// 每个城市的救援队人数</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">G</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, INT32_MAX))</span></span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
        <span class="hljs-built_in">cin</span> &gt;&gt; w[i];
    <span class="hljs-keyword">int</span> ui, vi, wi;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;
        <span class="hljs-built_in">cin</span> &gt;&gt; ui &gt;&gt; vi &gt;&gt; wi;
        G[ui][vi] = G[vi][ui] = wi;
    &#125;

    <span class="hljs-comment">// 先单纯使用Dijsktra算法计算出所有最短路径</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, INT32_MAX)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;())</span></span>;
    dist[src] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;
        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, minDist = INT32_MAX;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;
            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;
                u = j;
                minDist = dist[j];
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        visited[u] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; ++v) &#123;
            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INT32_MAX) &#123;
                <span class="hljs-keyword">int</span> tmp = G[u][v] + dist[u];
                <span class="hljs-keyword">if</span> (tmp &lt; dist[v]) &#123;    <span class="hljs-comment">// 更新最短路径</span>
                    dist[v] = tmp;
                    pre[v].<span class="hljs-built_in">clear</span>();
                    pre[v].push_back(u);
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp == dist[v])
                    pre[v].push_back(u);
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">// DFS得到最短路径条数和救援队最大人数</span>
    dfs(pre, w, dst, src);
    <span class="hljs-built_in">cout</span> &lt;&lt; ansNum &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; maxSum;
&#125;</code></pre>


</li>
</ul>
<h2 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h2><p>Floyd 算法可以用来解决多源最短路径问题，它会计算图中每两个点之间的最短路径。</p>
<p><strong>基本思想</strong>：如果令 k 作为顶点 i 和 j 之间路径的中介点能够得到一条更短的路径，则令 k 作为其最短路径的中介点。</p>
<p><strong>伪代码</strong>：(由伪代码可知 Floyd 算法的复杂度为 $O(n^3)$ ，所以通常用于图点数不太大的情况)</p>
<pre><code class="hljs c++"><span class="hljs-comment">// dist[i][j]表示顶点i和j之间的最短距离</span>

<span class="hljs-function"><span class="hljs-keyword">for</span> k <span class="hljs-title">in</span> <span class="hljs-params">(<span class="hljs-number">1</span>,n)</span>:	<span class="hljs-comment">// 令每个点分别作为中介点进行测试</span></span>
<span class="hljs-function">	<span class="hljs-keyword">for</span> i <span class="hljs-title">in</span> <span class="hljs-params">(<span class="hljs-number">1</span>,n)</span>:</span>
<span class="hljs-function">		<span class="hljs-keyword">for</span> j <span class="hljs-title">in</span> <span class="hljs-params">(<span class="hljs-number">1</span>,n)</span>:</span>
			if dist[i][j]&gt;dist[i][k]+dist[k][j]:
				dist[i][j]=dist[i][k]+dist[k][j]</code></pre>
<ul>
<li>注意一下这里的 k，也就是枚举的中介点必须在最外层才能保证这个贪心的正确性。因为 Floyd 算法的本质是 DP，也就是说<code>dist[k][i][j]=min(dist[k-1][i][j],dist[k-1][i][k]+dist[k-1][k][j])</code>，如果 k 不在最外层就不能保证当计算到 k 时，所有 k-1 的值都是最优的。</li>
</ul>
<p><strong>例：</strong> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">LeetCode-1334. 阈值距离内邻居最少的城市</a></p>
<ul>
<li><p>思想：用 Floyd 算法计算出每两个城市之间的最短距离，然后分别遍历每个城市，计算满足要求的邻居数量，返回邻居最少的城市。</p>
<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTheCity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;edges, <span class="hljs-keyword">int</span> distanceThreshold)</span> </span>&#123;
        <span class="hljs-comment">// 初始化邻接矩阵，也作为距离矩阵dist</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, INT32_MAX))</span></span>;
        <span class="hljs-keyword">int</span> len = edges.<span class="hljs-built_in">size</span>(), ui, vi, wi;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;
            ui = edges[i][<span class="hljs-number">0</span>], vi = edges[i][<span class="hljs-number">1</span>], wi = edges[i][<span class="hljs-number">2</span>];
            dist[ui][vi] = dist[vi][ui] = wi;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-comment">// 将到自身的距离初始化为0，下面的遍历中就不需要对kij三个点中有相等情况时的特殊处理</span>
            dist[i][i] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;
                    <span class="hljs-keyword">if</span> (dist[i][k] &lt; INT32_MAX &amp;&amp; dist[k][j] &lt; INT32_MAX &amp;&amp; (dist[i][k] + dist[k][j] &lt; dist[i][j]))
                        dist[i][j] = dist[i][k] + dist[k][j];
                &#125;
            &#125;
        &#125;

        <span class="hljs-comment">// 找出满足条件邻居最少的城市</span>
        <span class="hljs-keyword">int</span> ansCity, ansNum = INT32_MAX;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;
            <span class="hljs-keyword">int</span> tmpNum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;
                <span class="hljs-keyword">if</span> (dist[i][j] &lt;= distanceThreshold)
                    tmpNum++;
            &#125;
            <span class="hljs-keyword">if</span> (tmpNum &lt;= ansNum) &#123;
                ansNum = tmpNum;
                ansCity = i;
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> ansCity;

    &#125;
&#125;;</code></pre>


</li>
</ul>
<h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>Bellman-Ford 算法也是解决单源最短路径，其还可以处理有负边权的图。</p>
<p>首先要明确一点，在带有负边权的图中，不能有源点可达的负环，否则当从源点出发，将该负环循环走无数次，路径值会越来越小，也就不存在最短路径。所以当图中存在从源点可达的负环时，函数要返回 false。</p>
<p><strong>思路</strong>：将图 G 中的所有边，遍历 n-1 次。对于边<code>(u,v,w)</code>，若<code>dist[u]+w&lt;dist[v]</code>，则更新<code>dist[v]</code>。</p>
<ul>
<li><u>为什么要遍历所有边</u>：第 i 次遍历，其实是确定其他点分别到源点的最短路径上，第 i 个顶点是谁，也可以说是经过的第 i 条边是谁。</li>
<li><u>为什么要遍历 n-1 次</u>：在每个顶点到源点的最短路径上，顶点数最多为 n 个，除非有负环，所以最多只需要遍历 n-1 次(第一个顶点已经确定下来了)，就可以确定所有顶点的最短路径。</li>
</ul>
<p><strong>伪代码</strong>：</p>
<pre><code class="hljs c++">遍历n<span class="hljs-number">-1</span>次：
    对每条边(u,v,w)：
    	dist[v]=<span class="hljs-built_in">min</span>(dist[v],dist[u]+w)

<span class="hljs-comment">// 再遍历一次判断是否存在负环</span>
对每条边(u,v,w)：
    <span class="hljs-keyword">if</span> dist[u]+w&lt;dist[v]:	<span class="hljs-comment">// 若数组中还有未达到最优的值，只能说明图中有负环，返回false</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</code></pre>
<ul>
<li>在某次遍历中，如果所有的 dist 值都没有被优化，说明 dist 中所有值已经达到最优，可以直接退出循环。</li>
<li>如果要记录最短路径，可以设置一个<code>set&lt;int&gt; pre</code>，因为每次遍历会反复访问重复的点，而 set 可以自行去重。</li>
</ul>
<p><strong>例：</strong></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">LeetCode-787. K 站中转内最便宜的航班</a></p>
 <pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;flights, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dst, <span class="hljs-keyword">int</span> K)</span> </span>&#123;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, INT32_MAX)</span></span>;
        dist[src] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">int</span> len = flights.<span class="hljs-built_in">size</span>();
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(dist)</span></span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K + <span class="hljs-number">1</span>; ++i) &#123; <span class="hljs-comment">// K次中转，可以经过K+1条边</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j) &#123; <span class="hljs-comment">// 遍历每条边</span>
                <span class="hljs-keyword">int</span> u = flights[j][<span class="hljs-number">0</span>], v = flights[j][<span class="hljs-number">1</span>], w = flights[j][<span class="hljs-number">2</span>];
                <span class="hljs-keyword">if</span> (dist[u] &lt; INT32_MAX)
                    copy[v] = <span class="hljs-built_in">min</span>(copy[v], dist[u] + w);    <span class="hljs-comment">// 更新在copy上是为了防止在一次遍历中多次修改dist[i]的值，则其不止确定了一条边</span>
            &#125;
            dist = copy;
        &#125;

        <span class="hljs-keyword">return</span> dist[dst] == INT32_MAX ? <span class="hljs-number">-1</span> : dist[dst];
    &#125;
&#125;;</code></pre></li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-with-maximum-probability/">LeetCode-1514.概率最大的路径</a></p>
<ul>
<li><p>思路：这题咋一看有点唬人，其实也满足贪心策略，因为他要找的是最大相乘边权路径，而每个边权大小 ∈[0,1]，随着路径上边数的增加，边权只会越来越小，所以用 Bellman-Ford 算法时，最先得到的最大路径一定是最优解。</p>
  <pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">maxProbability</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;edges, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; &amp;succProb, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>&#123;
        <span class="hljs-keyword">int</span> len = edges.<span class="hljs-built_in">size</span>();
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">prob</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;
        prob[start] = <span class="hljs-number">1.0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;
            <span class="hljs-keyword">bool</span> isChange = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j) &#123;
                <span class="hljs-keyword">int</span> u = edges[j][<span class="hljs-number">0</span>], v = edges[j][<span class="hljs-number">1</span>];
                <span class="hljs-keyword">double</span> w = succProb[j];
                <span class="hljs-keyword">if</span> (prob[u] * w &gt; prob[v]) &#123;
                    prob[v] = prob[u] * w;
                    isChange = <span class="hljs-literal">true</span>;
                &#125;
                <span class="hljs-keyword">if</span> (prob[v] * w &gt; prob[u]) &#123;
                    prob[u] = prob[v] * w;
                    isChange = <span class="hljs-literal">true</span>;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (!isChange)
                <span class="hljs-keyword">break</span>;
        &#125;

        <span class="hljs-keyword">return</span> prob[<span class="hljs-built_in">end</span>];
    &#125;
&#125;;</code></pre>



</li>
</ul>
</li>
</ol>
<h2 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="SPFA 算法"></a>SPFA 算法</h2><p>SPFA 算法是基于 Bellman-Ford 算法改进得到的。B-F 算法每次边遍历，要对所有边都进行一次操作，但其实哪些边需要进行操作是可以提前确定的：只有当某个顶点 u 的 dist[u]值改变时，从他出发的边(u,v)才需要进行操作，因为只有此时顶点 v 的值才可能改变。</p>
<p><strong>基本操作：</strong>使用队列来存储 dist 值改变的点。每次取队首的顶点，然后对该顶点的所有边进行操作，如果边的另一个顶点的 dist 值改变，则将该顶点加入到队列中（如果该顶点当前不在队列中）。这样一直到队列为空。</p>
<ul>
<li>如果图中存在从源点可达的负环，则可能存在顶点无限次入队，使得队列不可能为空，这时用一个数组来记录每个顶点的入队次数，当一个顶点入队次数超过 n-1 时，返回 false。</li>
</ul>
<p><strong>伪代码：</strong></p>
<pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; in;	<span class="hljs-comment">// 标记顶点是否在队列中</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; count;	<span class="hljs-comment">// 记录顶点的入队次数</span>
<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
q.push(src);	<span class="hljs-comment">// 源点入队</span>
<span class="hljs-keyword">while</span>(!q.empty())&#123;
    <span class="hljs-keyword">int</span> u = q.pop();
    in[u] = <span class="hljs-literal">false</span>;
    对u的每条边进行松弛操作：
        若v的dist值改变且!in[v]：
        	q.push(v);
    		count[v]++;
    		in[v] = <span class="hljs-literal">true</span>;
    		<span class="hljs-keyword">if</span> count[v]&gt;n<span class="hljs-number">-1</span>:
    			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;</code></pre>
<p>例：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/">LeetCode-1129.颜色交替的最短路径</a></p>
<ul>
<li><p>思路：每个结点处添加颜色信息，以实现交替查找不同颜色的边。由于每个点可能多次访问，但是边不能重复访问，所以设置一个边访问表来记录边的访问情况。只要当前边没有访问过，就可以新建结点入队，这样保证了能得到所有解。</p>
<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> color;  <span class="hljs-comment">// 0表示由一条红边到该点，1表示由一条蓝边到该点</span>
    <span class="hljs-keyword">int</span> vertex; <span class="hljs-comment">// 顶点编号</span>
    <span class="hljs-keyword">int</span> len;    <span class="hljs-comment">// 长度</span>

    Node(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> l) &#123;
        color = c;
        vertex = v;
        len = l;
    &#125;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shortestAlternatingPaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;red_edges, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;blue_edges)</span> </span>&#123;
        <span class="hljs-comment">// 建立邻接表和边访问表</span>
        vector&lt;vector&lt;int&gt;&gt; redAdj(n, vector&lt;int&gt;()), blueAdj(n, vector&lt;int&gt;());
        vector&lt;vector&lt;bool&gt;&gt; redVis(n, vector&lt;bool&gt;()), blueVis(n, vector&lt;bool&gt;());
        <span class="hljs-keyword">int</span> redNum = red_edges.<span class="hljs-built_in">size</span>(), blueNum = blue_edges.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; redNum; ++i) &#123;
            redAdj[red_edges[i][<span class="hljs-number">0</span>]].push_back(red_edges[i][<span class="hljs-number">1</span>]);
            redVis[red_edges[i][<span class="hljs-number">0</span>]].push_back(<span class="hljs-literal">false</span>);
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; blueNum; ++i) &#123;
            blueAdj[blue_edges[i][<span class="hljs-number">0</span>]].push_back(blue_edges[i][<span class="hljs-number">1</span>]);
            blueVis[blue_edges[i][<span class="hljs-number">0</span>]].push_back(<span class="hljs-literal">false</span>);
        &#125;


        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, INT32_MAX)</span></span>;
        <span class="hljs-built_in">queue</span>&lt;Node&gt; q;
        q.push(Node(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));
        q.push(Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));
        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (!q.empty()) &#123;
            Node u = q.front();
            q.pop();

            <span class="hljs-keyword">if</span> (u.color == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 若u由一条蓝边到，找从u出发的红边</span>
                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nextRed = redAdj[u.vertex];
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nextRed.<span class="hljs-built_in">size</span>(); ++i) &#123;
                    <span class="hljs-keyword">int</span> v = nextRed[i];
                    <span class="hljs-comment">// 若该边未访问过，将结点入队</span>
                    <span class="hljs-keyword">if</span> (!redVis[u.vertex][i]) &#123;
                        redVis[u.vertex][i] = <span class="hljs-literal">true</span>;
                        q.push(Node(<span class="hljs-number">0</span>, v, u.len + <span class="hljs-number">1</span>));
                        ans[v] = <span class="hljs-built_in">min</span>(ans[v], u.len + <span class="hljs-number">1</span>);
                    &#125;
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nextBlue = blueAdj[u.vertex];
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nextBlue.<span class="hljs-built_in">size</span>(); ++i) &#123;
                    <span class="hljs-keyword">int</span> v = nextBlue[i];
                    <span class="hljs-keyword">if</span> (!blueVis[u.vertex][i]) &#123;
                        blueVis[u.vertex][i] = <span class="hljs-literal">true</span>;
                        q.push(Node(<span class="hljs-number">1</span>, v, u.len + <span class="hljs-number">1</span>));
                        ans[v] = <span class="hljs-built_in">min</span>(ans[v], u.len + <span class="hljs-number">1</span>);
                    &#125;

                &#125;
            &#125;
        &#125;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)
            ans[i] = (ans[i] == INT32_MAX) ? <span class="hljs-number">-1</span> : ans[i];

        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;;</code></pre></li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">LeetCode-787. K 站中转内最便宜的航班</a></p>
 <pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span>
    <span class="hljs-keyword">int</span> v;
    <span class="hljs-keyword">int</span> w;
    Edge(<span class="hljs-keyword">int</span> iv, <span class="hljs-keyword">int</span> iw) &#123;
        v = iv;
        w = iw;
    &#125;
&#125;;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>
    <span class="hljs-keyword">int</span> v;
    <span class="hljs-keyword">int</span> w;
    <span class="hljs-keyword">int</span> k;
    Node(<span class="hljs-keyword">int</span> iv, <span class="hljs-keyword">int</span> iw, <span class="hljs-keyword">int</span> ik) &#123;
        v = iv, w = iw, k = ik;
    &#125;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;flights, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dst, <span class="hljs-keyword">int</span> K)</span> </span>&#123;
        <span class="hljs-comment">// 初始化邻接表</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Edge&gt;&gt; <span class="hljs-title">adj</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;Edge&gt;())</span></span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;edge:flights)
            adj[edge[<span class="hljs-number">0</span>]].push_back(Edge(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]));

        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, INT32_MAX)</span></span>;
        res[src] = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">queue</span>&lt;Node&gt; q;
        q.push(Node(src, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));
        <span class="hljs-keyword">while</span> (!q.empty()) &#123;
            Node t = q.front();
            q.pop();
            <span class="hljs-keyword">if</span> (t.k &gt; K + <span class="hljs-number">1</span>)
                <span class="hljs-keyword">continue</span>;

            <span class="hljs-built_in">vector</span>&lt;Edge&gt; next = adj[t.v];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;tmp : next) &#123;
                <span class="hljs-keyword">int</span> w = tmp.w + t.w;
                <span class="hljs-keyword">if</span> (w &lt; res[tmp.v]) &#123;
                    res[tmp.v] = w;
                    q.push(Node(tmp.v, w, t.k + <span class="hljs-number">1</span>));
                &#125;
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> res[dst] == INT32_MAX ? <span class="hljs-number">-1</span> : res[dst];

    &#125;
&#125;;</code></pre></li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/%E6%80%BB%E7%BB%93/">总结</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/">最短路径</a>
                    
                      <a class="hover-with-bg" href="/tags/Dijsktra/">Dijsktra</a>
                    
                      <a class="hover-with-bg" href="/tags/Floyd/">Floyd</a>
                    
                      <a class="hover-with-bg" href="/tags/Bellman-Ford/">Bellman-Ford</a>
                    
                      <a class="hover-with-bg" href="/tags/SPFA/">SPFA</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/PAT/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2020.3月PAT经历(甲级满分)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/wt/">
                        <span class="hidden-mobile">Windows Terminal美化（配置Powershell7+PSReadLine+oh-my-posh）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 3,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "最短路径算法总结和LeetCode题目实践&nbsp;",
      ],
      cursorChar: "≯",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>









  <script>(function (i, s, o, g, r, a, m) {
      i['DaoVoiceObject'] = r;
      i[r] = i[r] ||
        function () {
          (i[r].q = i[r].q || []).push(arguments);
        };
      i[r].l = 1 * new Date();
      a = s.createElement(o);
      m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      a.charset = 'utf-8';
      m.parentNode.insertBefore(a, m);
    })(window, document, 'script', ('https:' === document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/dec76ed5.js", 'daovoice');
    daovoice('init', {
      app_id: "dec76ed5",
    });
    daovoice('update');
  </script>












</body>
</html>
