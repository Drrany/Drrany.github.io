<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Drrany</title>
  
  
  <link href="http://drrany.github.io/atom.xml" rel="self"/>
  
  <link href="http://drrany.github.io/"/>
  <updated>2021-01-29T07:48:11.438Z</updated>
  <id>http://drrany.github.io/</id>
  
  <author>
    <name>Drrany</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最短路径算法总结和LeetCode题目实践</title>
    <link href="http://drrany.github.io/ShortestPathAlgorithm/"/>
    <id>http://drrany.github.io/ShortestPathAlgorithm/</id>
    <published>2021-01-29T07:43:46.000Z</published>
    <updated>2021-01-29T07:48:11.438Z</updated>
    
    <content type="html"><![CDATA[<p>常见的最短路径算法总结。</p><a id="more"></a><h1 id="最短路径算法总结和-LeetCode-题目实践"><a href="#最短路径算法总结和-LeetCode-题目实践" class="headerlink" title="最短路径算法总结和 LeetCode 题目实践"></a>最短路径算法总结和 LeetCode 题目实践</h1><p>最近复习到了图相关，总结了最短路径问题的几个常用算法（Dijsktra 算法、Floyd 算法、Bellman-Ford 算法、SPFA 算法）。给出了具体题目实现。</p><p>给定图 G(V,E)，共有 n 个顶点：</p><h3 id="Dijsktra-算法"><a href="#Dijsktra-算法" class="headerlink" title="Dijsktra 算法"></a>Dijsktra 算法</h3><p>通常用于计算单源最短路径问题，即给定源点<code>src</code>，计算其他每个顶点到源点的最短距离。（注意：Dijsktra 不能解决边权有负值的情况）</p><p><strong>基本思想</strong>：设置一个顶点集合 S，存放已找到最短路径的顶点，每次从 V-S 集合中找距离源点距离最小的点，假设为<code>u</code>，将其加入集合 S。再次遍历 V-S 集合中的点，设为<code>v</code>，看是否能对边<code>(u,v)</code>进行松弛操作(<code>dist[u]+G[u][v]&lt;dist[v]</code>)。</p><p><strong>伪代码</strong>：</p><pre><code class="hljs c++"><span class="hljs-comment">// 设置的数据结构：</span><span class="hljs-keyword">bool</span> visited[n]; <span class="hljs-comment">// visited[i]=true表示顶点i已经加入集合S</span><span class="hljs-keyword">int</span> dist[n];     <span class="hljs-comment">// dist[i]表示顶点i距离源点的最短距离</span><span class="hljs-keyword">int</span> pre[n];         <span class="hljs-comment">// 到达pre[i]的最短路径上，i的前一个顶点</span>遍历n次：    找出V-S中距离源点最近的点，记为u    若不存在，说明G不是连通图    visited[u]=<span class="hljs-literal">true</span>    遍历V-S中所有点v        若dist[u]+G[u][v]&lt;dist[v]：            更新dist[v]和pre[v]</code></pre><p>例：</p><ol><li><p><a href="https://leetcode-cn.com/problems/network-delay-time/">LeetCode-743.网络延迟时间</a></p><ul><li><p>思路：计算源点到其他所有点所需的时间，记录在数组 dist[]中，返回 dist[]中的最大值，即延迟时间</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;times, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;   <span class="hljs-comment">// 将times转换为邻接矩阵G</span>   <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">G</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, INT32_MAX))</span></span>;   <span class="hljs-keyword">int</span> len = times.<span class="hljs-built_in">size</span>(), ui, vi, wi;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;       ui = times[i][<span class="hljs-number">0</span>], vi = times[i][<span class="hljs-number">1</span>], wi = times[i][<span class="hljs-number">2</span>];       G[ui][vi] = wi;   &#125;   <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT32_MAX)</span></span>; <span class="hljs-comment">// 到源点的距离</span>   <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// 是否加入集合S</span>   dist[k] = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 遍历n次</span>       <span class="hljs-comment">// 找出集合V-S中距离源点最近的</span>       <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, minDist = INT32_MAX;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;           <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;               u = j;               minDist = dist[j];           &#125;       &#125;       <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;   <span class="hljs-comment">// 若未找到，返回-1</span>       visited[u] = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 将u加入集合S</span>       <span class="hljs-comment">// 用顶点u更新V-S中其他顶点的最短距离</span>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) &#123;           <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INT32_MAX)               dist[v] = <span class="hljs-built_in">min</span>(dist[v], dist[u] + G[u][v]);       &#125;   &#125;   <span class="hljs-keyword">return</span> *max_element(dist.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, dist.<span class="hljs-built_in">end</span>());&#125;&#125;;</code></pre></li></ul></li><li><p><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">LeetCode-787. K 站中转内最便宜的航班</a></p><ul><li>思路：使用优先队列+Dijsktra 算法。记录到达每个结点(城市)处的中转次数和花费，优先操作花费最少的结点。</li></ul><p>&lt;!–hexoPostRenderEscape:<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">City</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br> <span class="hljs-keyword">int</span> index; <span class="hljs-comment">// 城市编号</span><br> <span class="hljs-keyword">int</span> cost;  <span class="hljs-comment">// 花费</span><br> <span class="hljs-keyword">int</span> hop;   <span class="hljs-comment">// 到达该城市的中转次数</span><br>City(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> h) &#123;<br> index = i, cost = c, hop = h;<br>&#125;</p><p> <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> City &amp;a, <span class="hljs-keyword">const</span> City &amp;b) &#123;</p><pre><code> &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a.cost &amp;gt; b.cost;</code></pre><p> &#125;<br>&#125;;</p></li></ol><p><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;flights, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dst, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-comment">// 将flights转换为邻接矩阵</span><br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">G</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, INT32_MAX))</span></span>;<br>        <span class="hljs-keyword">int</span> len = flights.<span class="hljs-built_in">size</span>(), ui, vi, wi;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            ui = flights[i][<span class="hljs-number">0</span>], vi = flights[i][<span class="hljs-number">1</span>], wi = flights[i][<span class="hljs-number">2</span>];<br>            G[ui][vi] = wi;<br>        &#125;</p><pre><code>    &lt;span class=&quot;hljs-comment&quot;&gt;// 创建优先队列，花费少的结点优先&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;priority_queue&lt;/span&gt;&amp;lt;City&amp;gt; pq;    pq.push(City(src, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;));    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!pq.empty()) &amp;#123;        City t = pq.top();        pq.pop();        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (t.hop &amp;gt; K + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;// k站中转，hop最大可以等于K+1&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; u = t.index, c = t.cost, h = t.hop;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (u == dst)   &lt;span class=&quot;hljs-comment&quot;&gt;// 若能到达目的地，则一定是最优花费的&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; c;        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; v = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; v &amp;lt; n; ++v) &amp;#123;            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (G[u][v] != INT32_MAX)                pq.push(City(v, G[u][v] + c, h + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;));        &amp;#125;    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;&amp;#125;</code></pre><p>&#125;;<br></code></pre>:hexoPostRenderEscape–&gt;</p><h4 id="Dijsktra-算法-DFS"><a href="#Dijsktra-算法-DFS" class="headerlink" title="Dijsktra 算法+DFS"></a>Dijsktra 算法+DFS</h4><p>上面两道题都没有要求输出具体的最短路径，所以没有使用 pre 数组。有两种稍微复杂的情况如下：</p><ol><li>源点到某个点的最短路径不止一条</li><li>不光要求从源点到其他点的距离最短，还有其他最优要求（e.g. 每个点有一个属性值，要求总属性值最大/小）</li></ol><p>第一个问题可以通过将 pre 数组修改为<code>vector&lt;vecotr&lt;int&gt; &gt;pre</code>，然后对<code>pre</code>进行 DFS 得到每条路径。</p><p>第二个问题，如果最优要求比较简单，可以直接在原有 Dijsktra 算法上修改，如果比较麻烦，可以先求出所有最短路径，再通过 DFS 对每条路径的属性进行比较，得到要求解。</p><p>例：[PAT-1003.Emergency][<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376]">https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376]</a></p><ul><li><p>思路：该题中不仅要求距离最短，还要求所有最短路径中，输出救援队人数最多的那条（也就是路径经过的所有城市点权相加）</p><p>&lt;!–hexoPostRenderEscape:<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></p></li></ul><p><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> maxSum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> ansNum = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; curPath;</p><p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; pre, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; w, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> src)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == src) &#123;<br>        ansNum++;<br>        curPath.push_back(u);<br>        <span class="hljs-comment">// 计算救援队总人数</span><br>        <span class="hljs-keyword">int</span> len = curPath.<span class="hljs-built_in">size</span>(), curSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)<br>            curSum += w[curPath[i]];<br>        maxSum = <span class="hljs-built_in">max</span>(maxSum, curSum);<br>        curPath.pop_back();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    curPath.push_back(u);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; last = pre[u];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; last.<span class="hljs-built_in">size</span>(); ++i)<br>        dfs(pre, w, last[i], src);</p><pre><code>curPath.pop_back();</code></pre><p>&#125;</p><p><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, src, dst;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; src &gt;&gt; dst;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(n)</span></span>;   <span class="hljs-comment">// 每个城市的救援队人数</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">G</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, INT32_MAX))</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        <span class="hljs-built_in">cin</span> &gt;&gt; w[i];<br>    <span class="hljs-keyword">int</span> ui, vi, wi;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; ui &gt;&gt; vi &gt;&gt; wi;<br>        G[ui][vi] = G[vi][ui] = wi;<br>    &#125;</p><pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// 先单纯使用Dijsktra算法计算出所有最短路径&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n, INT32_MAX)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n, &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;())&lt;/span&gt;&lt;/span&gt;;dist[src] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i) &amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; u = &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;, minDist = INT32_MAX;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j &amp;lt; n; ++j) &amp;#123;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!visited[j] &amp;amp;&amp;amp; dist[j] &amp;lt; minDist) &amp;#123;            u = j;            minDist = dist[j];        &amp;#125;    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (u == &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;    visited[u] = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; v = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; v &amp;lt; n; ++v) &amp;#123;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!visited[v] &amp;amp;&amp;amp; G[u][v] != INT32_MAX) &amp;#123;            &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; tmp = G[u][v] + dist[u];            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (tmp &amp;lt; dist[v]) &amp;#123;    &lt;span class=&quot;hljs-comment&quot;&gt;// 更新最短路径&lt;/span&gt;                dist[v] = tmp;                pre[v].&lt;span class=&quot;hljs-built_in&quot;&gt;clear&lt;/span&gt;();                pre[v].push_back(u);            &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (tmp == dist[v])                pre[v].push_back(u);        &amp;#125;    &amp;#125;&amp;#125;&lt;span class=&quot;hljs-comment&quot;&gt;// DFS得到最短路径条数和救援队最大人数&lt;/span&gt;dfs(pre, w, dst, src);&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; ansNum &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; maxSum;</code></pre><p>&#125;</code></pre>:hexoPostRenderEscape–&gt;</p><h3 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h3><p>Floyd 算法可以用来解决多源最短路径问题，它会计算图中每两个点之间的最短路径。</p><p><strong>基本思想</strong>：如果令 k 作为顶点 i 和 j 之间路径的中介点能够得到一条更短的路径，则令 k 作为其最短路径的中介点。</p><p><strong>伪代码</strong>：(由伪代码可知 Floyd 算法的复杂度为$O(n^3)$，所以通常用于图点数不太大的情况)</p><pre><code class="hljs c++"><span class="hljs-comment">// dist[i][j]表示顶点i和j之间的最短距离</span><span class="hljs-function"><span class="hljs-keyword">for</span> k <span class="hljs-title">in</span> <span class="hljs-params">(<span class="hljs-number">1</span>,n)</span>:    <span class="hljs-comment">// 令每个点分别作为中介点进行测试</span></span><span class="hljs-function">    <span class="hljs-keyword">for</span> i <span class="hljs-title">in</span> <span class="hljs-params">(<span class="hljs-number">1</span>,n)</span>:</span><span class="hljs-function">        <span class="hljs-keyword">for</span> j <span class="hljs-title">in</span> <span class="hljs-params">(<span class="hljs-number">1</span>,n)</span>:</span>            if dist[i][j]&gt;dist[i][k]+dist[k][j]:                dist[i][j]=dist[i][k]+dist[k][j]</code></pre><ul><li>注意一下这里的 k，也就是枚举的中介点必须在最外层才能保证这个贪心的正确性。因为 Floyd 算法的本质是 DP，也就是说<code>dist[k][i][j]=min(dist[k-1][i][j],dist[k-1][i][k]+dist[k-1][k][j])</code>，如果 k 不在最外层就不能保证当计算到 k 时，所有 k-1 的值都是最优的。</li></ul><p><strong>例：</strong></p><p><a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">LeetCode-1334. 阈值距离内邻居最少的城市</a></p><ul><li><p>思想：用 Floyd 算法计算出每两个城市之间的最短距离，然后分别遍历每个城市，计算满足要求的邻居数量，返回邻居最少的城市。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTheCity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;edges, <span class="hljs-keyword">int</span> distanceThreshold)</span> </span>&#123;      <span class="hljs-comment">// 初始化邻接矩阵，也作为距离矩阵dist</span>      <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, INT32_MAX))</span></span>;      <span class="hljs-keyword">int</span> len = edges.<span class="hljs-built_in">size</span>(), ui, vi, wi;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;          ui = edges[i][<span class="hljs-number">0</span>], vi = edges[i][<span class="hljs-number">1</span>], wi = edges[i][<span class="hljs-number">2</span>];          dist[ui][vi] = dist[vi][ui] = wi;      &#125;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-comment">// 将到自身的距离初始化为0，下面的遍历中就不需要对kij三个点中有相等情况时的特殊处理</span>          dist[i][i] = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;                  <span class="hljs-keyword">if</span> (dist[i][k] &lt; INT32_MAX &amp;&amp; dist[k][j] &lt; INT32_MAX &amp;&amp; (dist[i][k] + dist[k][j] &lt; dist[i][j]))                      dist[i][j] = dist[i][k] + dist[k][j];              &#125;          &#125;      &#125;      <span class="hljs-comment">// 找出满足条件邻居最少的城市</span>      <span class="hljs-keyword">int</span> ansCity, ansNum = INT32_MAX;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;          <span class="hljs-keyword">int</span> tmpNum = <span class="hljs-number">0</span>;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;              <span class="hljs-keyword">if</span> (dist[i][j] &lt;= distanceThreshold)                  tmpNum++;          &#125;          <span class="hljs-keyword">if</span> (tmpNum &lt;= ansNum) &#123;              ansNum = tmpNum;              ansCity = i;          &#125;      &#125;      <span class="hljs-keyword">return</span> ansCity;  &#125;&#125;;</code></pre></li></ul><h3 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h3><p>Bellman-Ford 算法也是解决单源最短路径，其还可以处理有负边权的图。</p><p>首先要明确一点，在带有负边权的图中，不能有源点可达的负环，否则当从源点出发，将该负环循环走无数次，路径值会越来越小，也就不存在最短路径。所以当图中存在从源点可达的负环时，函数要返回 false。</p><p><strong>思路</strong>：将图 G 中的所有边，遍历 n-1 次。对于边<code>(u,v,w)</code>，若<code>dist[u]+w&lt;dist[v]</code>，则更新<code>dist[v]</code>。</p><ul><li><u>为什么要遍历所有边</u>：第 i 次遍历，其实是确定其他点分别到源点的最短路径上，第 i 个顶点是谁，也可以说是经过的第 i 条边是谁。</li><li><u>为什么要遍历 n-1 次</u>：在每个顶点到源点的最短路径上，顶点数最多为 n 个，除非有负环，所以最多只需要遍历 n-1 次(第一个顶点已经确定下来了)，就可以确定所有顶点的最短路径。</li></ul><p><strong>伪代码</strong>：</p><pre><code class="hljs c++">遍历n<span class="hljs-number">-1</span>次：    对每条边(u,v,w)：        dist[v]=<span class="hljs-built_in">min</span>(dist[v],dist[u]+w)<span class="hljs-comment">// 再遍历一次判断是否存在负环</span>对每条边(u,v,w)：    <span class="hljs-keyword">if</span> dist[u]+w&lt;dist[v]:    <span class="hljs-comment">// 若数组中还有未达到最优的值，只能说明图中有负环，返回false</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</code></pre><ul><li>在某次遍历中，如果所有的 dist 值都没有被优化，说明 dist 中所有值已经达到最优，可以直接退出循环。</li><li>如果要记录最短路径，可以设置一个<code>set&lt;int&gt; pre</code>，因为每次遍历会反复访问重复的点，而 set 可以自行去重。</li></ul><p><strong>例：</strong></p><p><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">LeetCode-787. K 站中转内最便宜的航班</a></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;flights, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dst, <span class="hljs-keyword">int</span> K)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, INT32_MAX)</span></span>;        dist[src] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len = flights.<span class="hljs-built_in">size</span>();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(dist)</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K + <span class="hljs-number">1</span>; ++i) &#123; <span class="hljs-comment">// K次中转，可以经过K+1条边</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j) &#123; <span class="hljs-comment">// 遍历每条边</span>                <span class="hljs-keyword">int</span> u = flights[j][<span class="hljs-number">0</span>], v = flights[j][<span class="hljs-number">1</span>], w = flights[j][<span class="hljs-number">2</span>];                <span class="hljs-keyword">if</span> (dist[u] &lt; INT32_MAX)                    copy[v] = <span class="hljs-built_in">min</span>(copy[v], dist[u] + w);    <span class="hljs-comment">// 更新在copy上是为了防止在一次遍历中多次修改dist[i]的值，则其不止确定了一条边</span>            &#125;            dist = copy;        &#125;        <span class="hljs-keyword">return</span> dist[dst] == INT32_MAX ? <span class="hljs-number">-1</span> : dist[dst];    &#125;&#125;;</code></pre><p><a href="https://leetcode-cn.com/problems/path-with-maximum-probability/">LeetCode-1514.概率最大的路径</a></p><ul><li>思路：这题咋一看有点唬人，其实也满足贪心策略，因为他要找的是最大相乘边权路径，而每个边权大小 ∈[0,1]，随着路径上边数的增加，边权只会越来越小，所以用 Bellman-Ford 算法时，最先得到的最大路径一定是最优解。</li></ul><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">maxProbability</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;edges, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; &amp;succProb, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = edges.<span class="hljs-built_in">size</span>();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">prob</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;        prob[start] = <span class="hljs-number">1.0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;            <span class="hljs-keyword">bool</span> isChange = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j) &#123;                <span class="hljs-keyword">int</span> u = edges[j][<span class="hljs-number">0</span>], v = edges[j][<span class="hljs-number">1</span>];                <span class="hljs-keyword">double</span> w = succProb[j];                <span class="hljs-keyword">if</span> (prob[u] * w &gt; prob[v]) &#123;                    prob[v] = prob[u] * w;                    isChange = <span class="hljs-literal">true</span>;                &#125;                <span class="hljs-keyword">if</span> (prob[v] * w &gt; prob[u]) &#123;                    prob[u] = prob[v] * w;                    isChange = <span class="hljs-literal">true</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (!isChange)                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> prob[<span class="hljs-built_in">end</span>];    &#125;&#125;;</code></pre><h3 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="SPFA 算法"></a>SPFA 算法</h3><p>SPFA 算法是基于 Bellman-Ford 算法改进得到的。B-F 算法每次边遍历，要对所有边都进行一次操作，但其实哪些边需要进行操作是可以提前确定的：只有当某个顶点 u 的 dist[u]值改变时，从他出发的边(u,v)才需要进行操作，因为只有此时顶点 v 的值才可能改变。</p><p>基本操作：使用队列来存储 dist 值改变的点。每次取队首的顶点，然后对该顶点的所有边进行操作，如果边的另一个顶点的 dist 值改变，则将该顶点加入到队列中（如果该顶点当前不在队列中）。这样一直到队列为空。</p><ul><li>如果图中存在从源点可达的负环，则可能存在顶点无限次入队，使得队列不可能为空，这时用一个数组来记录每个顶点的入队次数，当一个顶点入队次数超过 n-1 时，返回 false。</li></ul><p>伪代码：</p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; in;    <span class="hljs-comment">// 标记顶点是否在队列中</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; count;    <span class="hljs-comment">// 记录顶点的入队次数</span><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;q.push(src);    <span class="hljs-comment">// 源点入队</span><span class="hljs-keyword">while</span>(!q.empty())&#123;    <span class="hljs-keyword">int</span> u = q.pop();    in[u] = <span class="hljs-literal">false</span>;    对u的每条边进行松弛操作：        若v的dist值改变且!in[v]：            q.push(v);            count[v]++;            in[v] = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span> count[v]&gt;n<span class="hljs-number">-1</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>例：</p><p><a href="https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/">LeetCode-1129.颜色交替的最短路径</a></p><ul><li><p>思路：每个结点处添加颜色信息，以实现交替查找不同颜色的边。由于每个点可能多次访问，但是边不能重复访问，所以设置一个边访问表来记录边的访问情况。只要当前边没有访问过，就可以新建结点入队，这样保证了能得到所有解。</p><p>&lt;!–hexoPostRenderEscape:<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">int</span> color;  <span class="hljs-comment">// 0表示由一条红边到该点，1表示由一条蓝边到该点</span><br>  <span class="hljs-keyword">int</span> vertex; <span class="hljs-comment">// 顶点编号</span><br>  <span class="hljs-keyword">int</span> len;    <span class="hljs-comment">// 长度</span></p><p>  Node(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> l) &#123;</p><pre><code>  color = c;  vertex = v;  len = l;</code></pre><p>  &#125;<br>&#125;;</p></li></ul><p><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shortestAlternatingPaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;red_edges, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;blue_edges)</span> </span>&#123;<br>        <span class="hljs-comment">// 建立邻接表和边访问表</span><br>        vector&lt;vector&lt;int&gt;&gt; redAdj(n, vector&lt;int&gt;()), blueAdj(n, vector&lt;int&gt;());<br>        vector&lt;vector&lt;bool&gt;&gt; redVis(n, vector&lt;bool&gt;()), blueVis(n, vector&lt;bool&gt;());<br>        <span class="hljs-keyword">int</span> redNum = red_edges.<span class="hljs-built_in">size</span>(), blueNum = blue_edges.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; redNum; ++i) &#123;<br>            redAdj[red_edges[i][<span class="hljs-number">0</span>]].push_back(red_edges[i][<span class="hljs-number">1</span>]);<br>            redVis[red_edges[i][<span class="hljs-number">0</span>]].push_back(<span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; blueNum; ++i) &#123;<br>            blueAdj[blue_edges[i][<span class="hljs-number">0</span>]].push_back(blue_edges[i][<span class="hljs-number">1</span>]);<br>            blueVis[blue_edges[i][<span class="hljs-number">0</span>]].push_back(<span class="hljs-literal">false</span>);<br>        &#125;</p><pre><code>    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(n, INT32_MAX)&lt;/span&gt;&lt;/span&gt;;    &lt;span class=&quot;hljs-built_in&quot;&gt;queue&lt;/span&gt;&amp;lt;Node&amp;gt; q;    q.push(Node(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;));    q.push(Node(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;));    ans[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!q.empty()) &amp;#123;        Node u = q.front();        q.pop();        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (u.color == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &amp;#123; &lt;span class=&quot;hljs-comment&quot;&gt;// 若u由一条蓝边到，找从u出发的红边&lt;/span&gt;            &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; nextRed = redAdj[u.vertex];            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nextRed.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;(); ++i) &amp;#123;                &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; v = nextRed[i];                &lt;span class=&quot;hljs-comment&quot;&gt;// 若该边未访问过，将结点入队&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!redVis[u.vertex][i]) &amp;#123;                    redVis[u.vertex][i] = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;                    q.push(Node(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, v, u.len + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;));                    ans[v] = &lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(ans[v], u.len + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);                &amp;#125;            &amp;#125;        &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &amp;#123;            &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; nextBlue = blueAdj[u.vertex];            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nextBlue.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;(); ++i) &amp;#123;                &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; v = nextBlue[i];                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!blueVis[u.vertex][i]) &amp;#123;                    blueVis[u.vertex][i] = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;                    q.push(Node(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, v, u.len + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;));                    ans[v] = &lt;span class=&quot;hljs-built_in&quot;&gt;min&lt;/span&gt;(ans[v], u.len + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);                &amp;#125;            &amp;#125;        &amp;#125;    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; i &amp;lt; n; ++i)        ans[i] = (ans[i] == INT32_MAX) ? &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt; : ans[i];    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ans;&amp;#125;</code></pre><p>&#125;;</code></pre>:hexoPostRenderEscape–&gt;</p><p><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">LeetCode-787. K 站中转内最便宜的航班</a></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span>    <span class="hljs-keyword">int</span> v;    <span class="hljs-keyword">int</span> w;    Edge(<span class="hljs-keyword">int</span> iv, <span class="hljs-keyword">int</span> iw) &#123;        v = iv;        w = iw;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>    <span class="hljs-keyword">int</span> v;    <span class="hljs-keyword">int</span> w;    <span class="hljs-keyword">int</span> k;    Node(<span class="hljs-keyword">int</span> iv, <span class="hljs-keyword">int</span> iw, <span class="hljs-keyword">int</span> ik) &#123;        v = iv, w = iw, k = ik;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;flights, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dst, <span class="hljs-keyword">int</span> K)</span> </span>&#123;        <span class="hljs-comment">// 初始化邻接表</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Edge&gt;&gt; <span class="hljs-title">adj</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;Edge&gt;())</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;edge:flights)            adj[edge[<span class="hljs-number">0</span>]].push_back(Edge(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]));        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, INT32_MAX)</span></span>;        res[src] = <span class="hljs-number">0</span>;        <span class="hljs-built_in">queue</span>&lt;Node&gt; q;        q.push(Node(src, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));        <span class="hljs-keyword">while</span> (!q.empty()) &#123;            Node t = q.front();            q.pop();            <span class="hljs-keyword">if</span> (t.k &gt; K + <span class="hljs-number">1</span>)                <span class="hljs-keyword">continue</span>;            <span class="hljs-built_in">vector</span>&lt;Edge&gt; next = adj[t.v];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;tmp : next) &#123;                <span class="hljs-keyword">int</span> w = tmp.w + t.w;                <span class="hljs-keyword">if</span> (w &lt; res[tmp.v]) &#123;                    res[tmp.v] = w;                    q.push(Node(tmp.v, w, t.k + <span class="hljs-number">1</span>));                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res[dst] == INT32_MAX ? <span class="hljs-number">-1</span> : res[dst];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的最短路径算法总结。&lt;/p&gt;</summary>
    
    
    <content src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20210129-153447-0094.jfif" type="image"/>
    
    
    <category term="算法" scheme="http://drrany.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="总结" scheme="http://drrany.github.io/categories/%E7%AE%97%E6%B3%95/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="算法" scheme="http://drrany.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="最短路径" scheme="http://drrany.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    <category term="Dijsktra" scheme="http://drrany.github.io/tags/Dijsktra/"/>
    
    <category term="Floyd" scheme="http://drrany.github.io/tags/Floyd/"/>
    
    <category term="Bellman-Ford" scheme="http://drrany.github.io/tags/Bellman-Ford/"/>
    
    <category term="SPFA" scheme="http://drrany.github.io/tags/SPFA/"/>
    
  </entry>
  
  <entry>
    <title>Windows Terminal美化（配置Powershell7+PSReadLine+oh-my-posh）</title>
    <link href="http://drrany.github.io/wt/"/>
    <id>http://drrany.github.io/wt/</id>
    <published>2020-08-19T05:51:08.000Z</published>
    <updated>2020-09-20T08:53:16.582Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好看是第一生产力。    — 鲁迅</p></blockquote><a id="more"></a><blockquote><p>最终效果如封面。</p></blockquote><h1 id="Windows-Terminal基础配置"><a href="#Windows-Terminal基础配置" class="headerlink" title="Windows Terminal基础配置"></a>Windows Terminal基础配置</h1><h2 id="Scoop安装"><a href="#Scoop安装" class="headerlink" title="Scoop安装"></a>Scoop安装</h2><p>Scoop是一款Windows下的包管理器，不是必须安装的，但是之后的部分配置我是用Scoop下载的。<br>Scoop的安装：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> set-executionpolicy remotesigned -scope currentuser</span><span class="hljs-meta">$</span><span class="bash"> iex (new-object net.webclient).downloadstring(<span class="hljs-string">&#x27;https://get.scoop.sh&#x27;</span>)</span><span class="hljs-meta">#</span><span class="bash"> 测试是否安装成功：</span>scoop help</code></pre><h3 id="Scoop快速入门"><a href="#Scoop快速入门" class="headerlink" title="Scoop快速入门"></a>Scoop快速入门</h3><p>以安装Python为例：</p><ol><li>搜索软件包（会在你现在安装的仓库里搜索）：<code>scoop search python</code></li><li>安装：<code>scoop install python</code> （可以先使用<code>scoop info python</code>查看当前软件的详细信息看是不是你需要的）</li><li>提示安装成功后，可以通过 <code>scoop list</code> 查看当前安装的软件</li><li>卸载：<code>scoop uninstall python</code></li><li>更新：<code>scoop update python</code>（可以先通过<code>scoop status</code>查看当前是否有可更新的软件）。也可以使用命令 <code>scoop update *</code> 直接更新所有软件包括scoop自身。</li><li>清理历史版本软件包与缓存：<code>scoop cleanup *</code>。scoop更新软件后不会自动卸载旧版本的软件包，需要手动cleanup来清理。</li></ol><p>Scoop安装的软件存放路径：<code>C:\Users\用户名\scoop</code></p><h3 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h3><p>Scoop自带的官方仓库main的软件比较少，不太能满足我们的需求，但是它有一个bucket软件源策略，而且有社区来维护，常用软件基本能够找到。</p><p>bucket官方维护源包括：（输入命令<code> scoop bucket known</code> 可以查看）</p><pre><code class="hljs shell">scoop bucket add main # 默认scoop bucket add extras # 推荐scoop bucket add versions # 收录软件包的历史版本scoop bucket add nightliesscoop bucket add nirsoftscoop bucket add phpscoop bucket add nerd-fonts # 编程字体scoop bucket add nonportablescoop bucket add javascoop bucket add gamesscoop bucket add jetbrains # 推荐</code></pre><p>也可以添加第三方的，语法格式为：<code>scoop bucket add [仓库名] [仓库地址]</code></p><p>例如添加一个包括一些国内常用应用（微信、QQ、网易云音乐）的第三方库：<br><code>scoop bucket add dorado https://github.com/chawyehsu/dorado</code></p><p>移除仓库：<code>scoop rm php</code></p><h3 id="Scoop命令不完全指北"><a href="#Scoop命令不完全指北" class="headerlink" title="Scoop命令不完全指北"></a>Scoop命令不完全指北</h3><p><code>scoop help</code> 获取命令帮助列表<br><code>scoop install 软件名</code> 安装<br><code>scoop install 软件名@3.7.6</code> 安装指定版本<br><code>scoop install extras/sumatrapdf</code> 安装指定仓库内版本<br><code>scoop update 软件名</code> 更新<br><code>scoop update *</code> 更新Scoop、所有安装的软件<br><code>scoop cleanup *</code> 清理历史版本软件包与缓存<br><code>scoop uninstall 软件名</code> 卸载<br><code>scoop reset 软件名</code> 版本切换<br><code>scoop depends 软件名</code> 查看软件的依赖<br><code>scoop hold 软件名</code>  禁止软件更新<br><code>scoop unhold 软件名</code>  启动软件更新<br><code>scoop home 软件名</code>  打开软件主页<br><code>scoop info 软件名</code>  显示软件信息<br><code>scoop list</code>   列出所有已安装软件<br><code>scoop prefix 软件名</code>  查看软件路径<br><code>scoop reset 软件名</code>  恢复软件版本<br><code>scoop search 软件名</code>  搜索软件<br><code>scoop status 软件名</code>  查看软件更新状态</p><h3 id="gsudo安装"><a href="#gsudo安装" class="headerlink" title="gsudo安装"></a>gsudo安装</h3><p>gsudo解决了管理员权限问题，不需要再单独打开管理员权限的Powershell窗口。<br>安装：<code>scoop install gsudo</code><br>使用：在需要使用的命令前添加 <code>gsudo</code> 即可。（或者只输入命令<code>gsudo</code>，则直接进入管理员模式）</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>Windows Terminal下载：</p><ul><li>方式一：<a href="">Windows Terminal下载</a> </li><li>方式二：直接在 Microsoft Store 搜索下载</li><li>方式三：使用 Scoop 安装（通过 <a href="https://github.com/h404bi">@h404bi</a> 维护的第三方 bucket）<pre><code class="hljs shell">scoop bucket add dorado https://github.com/h404bi/doradoscoop install windowsterminal</code></pre></li></ul><br><p><a href="https://github.com/PowerShell/PowerShell/releases">PowerShell 7下载</a></p><h2 id="WT配置自定义"><a href="#WT配置自定义" class="headerlink" title="WT配置自定义"></a>WT配置自定义</h2><p>打开配置文件：</p><div align=center><img src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200819141247.png" width=60%></div><h3 id="自定义全局属性"><a href="#自定义全局属性" class="headerlink" title="自定义全局属性"></a>自定义全局属性</h3><p>位于配置文件最开始的位置，可修改的全部属性参考：<a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/global-settings">全局设置</a><br>我修改的配置：</p><ul><li>Terminal 亮暗主题：<code>&quot;theme&quot;: &quot;dark&quot;</code></li></ul><h3 id="自定义环境入口-添加新Shell"><a href="#自定义环境入口-添加新Shell" class="headerlink" title="自定义环境入口(添加新Shell)"></a>自定义环境入口(添加新Shell)</h3><p>Windows Terminal 下拉菜单中可选择的环境是能自由配置的，其中每个环境有可以单独设置字体，初始目录，配色方案，背景等等。</p><p>环境的配置位于<code>profiles[]</code>中：</p><div align=center><img src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200819144453.png" width=100%></div><p>一个典型的环境配置包括（以我配置的PowerShell7为例）：</p><pre><code class="hljs json">&#123;    <span class="hljs-comment">// 下拉菜单中显示的名字</span>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;PowerShell7&quot;</span>,    <span class="hljs-comment">// 下拉菜单中显示的icon</span>    <span class="hljs-comment">// 路径的语法格式可以用： </span>    <span class="hljs-comment">//      1. ms-appdata:///roaming/&#123;图片路径&#125;</span>    <span class="hljs-comment">//      2. 直接填图片路径 </span>    <span class="hljs-attr">&quot;icon&quot;</span>: <span class="hljs-string">&quot;ms-appdata:///roaming/E:\\保存图片\\icon\\cloudshell.png&quot;</span>,     <span class="hljs-comment">// 标识符，直接在PowerShell中输入命令 new-guid 就可以得到一个新的GUID</span>    <span class="hljs-comment">// 如果guid设置为和全局属性的&quot;defaultProfile&quot;一样的话，打开 WT 就会默认为这个环</span>    <span class="hljs-attr">&quot;guid&quot;</span>: <span class="hljs-string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span>,         <span class="hljs-comment">// 唤起环境时执行这一命令，我这里加了个参数不输出启动日志信息</span>    <span class="hljs-attr">&quot;commandline&quot;</span>: <span class="hljs-string">&quot;path\\pwsh.exe -nologo&quot;</span>,     <span class="hljs-comment">// 唤起环境时所处的起始目录</span>    <span class="hljs-attr">&quot;startingDirectory&quot;</span>: <span class="hljs-string">&quot;path\\...&quot;</span>,     <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#fa9395&quot;</span>, <span class="hljs-comment">// 光标的颜色</span>    <span class="hljs-attr">&quot;cursorShape&quot;</span>: <span class="hljs-string">&quot;vintage&quot;</span>, <span class="hljs-comment">// 光标的形状。包括：bar、empytBox、filledBox、vintage</span>    <span class="hljs-attr">&quot;colorScheme&quot;</span>: <span class="hljs-string">&quot;Chalkboard&quot;</span>, <span class="hljs-comment">// 配色方案，除了几个默认的还可以在下面的&quot;schemes&quot;: []中定义</span>    <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#2a2a2a&quot;</span>, <span class="hljs-comment">// 背景色</span>    <span class="hljs-attr">&quot;useAcrylic&quot;</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开启毛玻璃特效</span>    <span class="hljs-attr">&quot;acrylicOpacity&quot;</span>: <span class="hljs-number">0.3</span>, <span class="hljs-comment">// 毛玻璃特效的不透明度</span>    <span class="hljs-attr">&quot;backgroundImage&quot;</span>: <span class="hljs-string">&quot;path\\IMG_111.jpg&quot;</span>, <span class="hljs-comment">// 背景图片</span>    <span class="hljs-attr">&quot;backgroundImageOpacity&quot;</span>: <span class="hljs-number">0.5</span> <span class="hljs-comment">// 背景图片的不透明度</span>&#125;</code></pre><p>更多详细配置参考：<a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/profile-settings">配置文件设置</a></p><h3 id="添加自定义配色方案"><a href="#添加自定义配色方案" class="headerlink" title="添加自定义配色方案"></a>添加自定义配色方案</h3><p>一个可以预览Windows Terminal主题并一键复制json文件的网站：<a href="https://atomcorp.github.io/themes/">Windows Terminal Themes</a></p><div align=center><img src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200819150228.png" width=100%></div><p>点击下面的<code>Get theme</code>即将json文件复制到剪切板。e.g.</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Andromeda&quot;</span>,  <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#000000&quot;</span>,  <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#cd3131&quot;</span>,  <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#05bc79&quot;</span>,  <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#e5e512&quot;</span>,  <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#2472c8&quot;</span>,  <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#bc3fbc&quot;</span>,  <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#0fa8cd&quot;</span>,  <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#e5e5e5&quot;</span>,  <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#666666&quot;</span>,  <span class="hljs-comment">//命令行参数</span>  <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#cd3131&quot;</span>,  <span class="hljs-comment">//错误信息</span>  <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#05bc79&quot;</span>,  <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#e5e512&quot;</span>,  <span class="hljs-comment">//命令</span>  <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#2472c8&quot;</span>,  <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#bc3fbc&quot;</span>,  <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#0fa8cd&quot;</span>,  <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#e5e5e5&quot;</span>,  <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#262a33&quot;</span>,  <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#e5e5e5&quot;</span>&#125;</code></pre><p>我标识了几个颜色代表的参数，都不喜欢也可以自己DIY。</p><h3 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h3><p>在<code>&quot;keybindings&quot;: []</code>进行设置。默认的包括：</p><ul><li><code>Ctrl</code> + <code>Shift</code> + <code>F</code>：全局查找</li><li><code>Ctrl</code> + <code>Shift</code> + <code>T</code>：打开新标签页</li><li><code>Ctrl</code> + <code>Shift</code> + <code>1/2/3...</code>：进入配置文件中定义的第一/二/三/…个环境</li><li><code>Ctrl</code> + <code>Tab</code>：前一个标签页</li><li><code>Ctrl</code> + <code>Shift</code> + <code>Tab</code>：后一个标签页</li><li><code>Alt</code> + <code>Shift</code> + <code>-</code>：横向分屏</li><li><code>Alt</code> + <code>Shift</code> + <code>+</code>：纵向分屏</li><li><code>Ctrl</code> + <code>+</code>：放大</li><li><code>Ctrl</code> + <code>-</code>：缩小</li><li><code>Ctrl</code> + <code>0</code>：恢复默认缩放比例</li></ul><p>更多详细配置参考：<a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/key-bindings">自定义键绑定</a></p><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="oh-my-posh安装和配置"><a href="#oh-my-posh安装和配置" class="headerlink" title="oh-my-posh安装和配置"></a>oh-my-posh安装和配置</h2><p>打开管理员权限的Powershell窗口（安装了gsudo的可以在命令前面直接加上<code>gsudo</code>）：</p><pre><code class="hljs shell">Install-Module posh-git # 如果你的电脑里没有安装Git，输入这行会报错，解决方法是安装Git或者把这一行去掉。Install-Module oh-my-poshSet-Theme Agnoster # 这个是设置主题，你也可以选其他的，通过命令Get-Theme命令来查看其他主题</code></pre><p>上面的导入只对当前窗口有效，所以需要将其添加到配置文件中：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-keyword">if</span> (!(Test-Path -Path <span class="hljs-variable">$PROFILE</span> )) &#123; New-Item -Type File -Path <span class="hljs-variable">$PROFILE</span> -Force &#125; notepad <span class="hljs-variable">$PROFILE</span></span><span class="hljs-meta">#</span><span class="bash"> 该命令打开默认 PowerShell 的启动配置文件（如果没有就创建），notepad表示用记事本打开，如果你安装了vscode，也可以替换成 code</span><span class="hljs-meta">#</span><span class="bash"> 已经存在启动配置文件的话可以直接用命令 notepad/code <span class="hljs-variable">$PROFILE</span> 打开</span></code></pre><p>然后把前面三行内容复制到 Microsoft.PowerShell_profile.ps1 文件中。<br>重新打开窗口或者输入命令<code>.$Profile</code>让配置文件生效。</p><blockquote><p>oh-my-posh只支持部分字体，可以使用我目前用的这款：<a href="https://github.com/tonsky/FiraCode/releases">Fira Code</a></p></blockquote><h3 id="隐藏主机名"><a href="#隐藏主机名" class="headerlink" title="隐藏主机名"></a>隐藏主机名</h3><blockquote><p>个人觉得命令行前面显示的一长串太难看了。</p></blockquote><ol><li><p>找到oh-my-posh的主题文件夹。</p><ul><li>如果你安装有everything可以直接搜索Agnoster或者任意主题名字试试。</li><li>没有的话应该在这个路径下：<code>C:\Users\你的用户名\Documents\PowerShell\Modules\oh-my-posh\2.0.465\Themes</code></li></ul></li><li><p>打开对应主题的.psm1文件，比如我使用的 Agnoster.psm1，搜索 <code>$user@$computer</code> 定位到如下内容，直接将整个 if语句 注释掉。</p> <div align=center><img src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200819195157.png" width=100%></div></li></ol><h2 id="PSReadLine安装和配置"><a href="#PSReadLine安装和配置" class="headerlink" title="PSReadLine安装和配置"></a>PSReadLine安装和配置</h2><blockquote><p>PSReadLine 是一个由微软发布的用于 PowerShell 的行读取实现，提供了以下功能：</p><ul><li>语法着色</li><li>简单语法错误通知</li><li>良好的多行体验</li><li>可自定义的键绑定</li><li>Cmd和Emacs模式</li><li>许多配置选项</li><li>Bash 样式的补全</li><li>Bash/zsh 样式的交互式历史记录搜索</li><li>Emacs yank/kill ring</li><li>基于 PowerShell Token 的单词移动和删除</li><li>撤销/重做</li><li>自动保存历史记录，包括在实时会话中共享历史记录</li><li>菜单补全、Intellisense</li></ul></blockquote><p><strong>安装</strong>：<code>$ Install-Module -Name PSReadLine -AllowPrerelease -Force</code><br><strong>打开配置文件</strong>：<code>code $PROFILE</code><br>在里面添加以下内容：</p><pre><code class="hljs sql"><span class="hljs-keyword">Set</span>-PSReadLineOption -PredictionSource History <span class="hljs-comment"># 设置预测文本来源为历史记录</span> <span class="hljs-keyword">Set</span>-PSReadlineKeyHandler -<span class="hljs-keyword">Key</span> Tab -<span class="hljs-keyword">Function</span> <span class="hljs-keyword">Complete</span> <span class="hljs-comment"># 设置 Tab 键补全</span><span class="hljs-keyword">Set</span>-PSReadLineKeyHandler -<span class="hljs-keyword">Key</span> <span class="hljs-string">&quot;Ctrl+d&quot;</span> -<span class="hljs-keyword">Function</span> MenuComplete <span class="hljs-comment"># 设置 Ctrl+d 为菜单补全和 Intellisense</span><span class="hljs-keyword">Set</span>-PSReadLineKeyHandler -<span class="hljs-keyword">Key</span> <span class="hljs-string">&quot;Ctrl+z&quot;</span> -<span class="hljs-keyword">Function</span> <span class="hljs-keyword">Undo</span> <span class="hljs-comment"># 设置 Ctrl+z 为撤销</span><span class="hljs-keyword">Set</span>-PSReadLineKeyHandler -<span class="hljs-keyword">Key</span> UpArrow -<span class="hljs-keyword">Function</span> HistorySearchBackward <span class="hljs-comment"># 设置向上键为后向搜索历史记录</span><span class="hljs-keyword">Set</span>-PSReadLineKeyHandler -<span class="hljs-keyword">Key</span> DownArrow -<span class="hljs-keyword">Function</span> HistorySearchForward <span class="hljs-comment"># 设置向下键为前向搜索历史纪录</span></code></pre><p><a href="https://github.com/PowerShell/PSReadLine">PSReadLine更多配置参考</a></p><h2 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h2><p>经常使用Git，所以想设置一些简短点的别名。<br>powershell的别名不支持语句，只能用命令所以这里还是搞了蛮久的。<br>需要用函数来帮忙，举个🌰 ：假如我想设置<code>git commit -m</code> -&gt; <code>cm</code>。因为后面肯定是有个字符串参数的，所以在配置文件里要这么写：</p><pre><code class="hljs ps1"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCommit</span><span class="hljs-params">()</span></span> &#123;      git commit <span class="hljs-literal">-m</span> <span class="hljs-variable">$args</span>&#125;<span class="hljs-built_in">Set-Alias</span> cm getCommit</code></pre><p>另外这个函数名<code>getCommit</code>是不能随便起的，有一定的规范，按我这种写应该是没问题的。<br>如果是不带参数的命令，就可以去掉<code>$args</code>。<br><a href="https://www.pstips.net/powershell-alias.html">Powershell 别名详细参考</a></p><br><br><hr><p>参考网址：<br><a href="https://sspai.com/post/59380">https://sspai.com/post/59380</a><br><a href="https://docs.microsoft.com/zh-cn/windows/terminal/">https://docs.microsoft.com/zh-cn/windows/terminal/</a><br><a href="https://segmentfault.com/a/1190000023337501">https://segmentfault.com/a/1190000023337501</a><br><a href="https://zhuanlan.zhihu.com/p/137251716">https://zhuanlan.zhihu.com/p/137251716</a><br><a href="https://printempw.github.io/windows-terminal-setup-guide/#3-2-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE">https://printempw.github.io/windows-terminal-setup-guide/#3-2-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;好看是第一生产力。    — 鲁迅&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    <content src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200819134026.png" type="image"/>
    
    
    <category term="配置" scheme="http://drrany.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="记录" scheme="http://drrany.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Windows" scheme="http://drrany.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>GithubPages+Hexo搭建个人博客记录</title>
    <link href="http://drrany.github.io/GithubPages+Hexo/"/>
    <id>http://drrany.github.io/GithubPages+Hexo/</id>
    <published>2020-08-13T07:30:46.000Z</published>
    <updated>2020-11-29T12:30:43.744Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下简单流程和出现的问题。</p><a id="more"></a><blockquote><p>本文基本上是一个基本步骤的记录，没有太多的讲解，如果希望了解更多原理性知识，推荐阅读文章末尾的链接。</p><p>提示：部分网上很多的安装教程基本都进行了简略，以后闲的话可能会补一下（flag插好_(:з」∠)_）</p></blockquote><h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><p>首先明确需求：</p><ul><li><p>服务器：GitHub Pages</p></li><li><p>博客框架：Hexo</p></li></ul><p>因此要做的准备有如下：</p><h2 id="1-准备GitHub-Pages"><a href="#1-准备GitHub-Pages" class="headerlink" title="1. 准备GitHub Pages"></a>1. 准备GitHub Pages</h2><ol><li>安装 <a href="https://git-scm.com/">git</a><br> 通过  <code>$ git --version</code> 测试是否安装成功。</li><li>注册GitHub账户并配置SSH key</li><li>在GitHub上开启GitHub pages服务（其实就是创建一个仓库，仓库的名字必须是 username.github.io）<br>到这步可以测试一下：在浏览器输入 <code>https://username.github.io</code> 能否访问成功</li></ol><h2 id="2-准备Hexo"><a href="#2-准备Hexo" class="headerlink" title="2. 准备Hexo"></a>2. 准备Hexo</h2><ol><li><p>安装 <a href="https://nodejs.org/en/">node.js</a><br>通过 <code>$ node --version</code> 测试是否安装成功。</p></li><li><p>通过<code>npm</code>安装 <code>Hexo</code>，终端输入命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -g hexo-cli</span></code></pre></li><li><p>创建站点根目录（站点根目录中的文件就是我们博客所需的资源）：<br>Hexo会在指定的这个站点根目录中创建所需要的文件</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> hexo init &lt;指定目录&gt;</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> &lt;指定目录&gt;</span><span class="hljs-meta">$</span><span class="bash"> npm install</span></code></pre></li><li><p>预览博客：输入 <code>$ hexo server</code> 。浏览器访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 即可看到当前根目录对应的博客资源</p></li><li><p>根据站点根目录内容生成静态文件：输入 <code>$ hexo generate</code>。生成的文件位于 <code>/public/</code> 文件夹中，下一步就需要将生成的静态文件上传到GitHub仓库中</p></li></ol><h3 id="2-1-站点目录结构分析"><a href="#2-1-站点目录结构分析" class="headerlink" title="2.1 站点目录结构分析"></a>2.1 站点目录结构分析</h3><ul><li><p><code>.deploy_git</code>：<code>hexo g</code> 生成</p></li><li><p><code>node_modules/</code>：安装包的目录，执行 <code>npm install</code> 的时候会重新生成</p></li><li><p><code>scaffolds/</code>：文章的布局</p><ul><li><p>当创建新的文章时，Hexo会根据scaffold里的不同布局来建立文件，默认布局由 <code>_config.yml</code> 中的 <code>default_layout</code> 参数指定。</p></li><li><p>不同布局创建的文章保存路径有所区别：</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td><code>source/_post</code></td></tr><tr><td>page</td><td><code>source/</code></td></tr><tr><td>draft</td><td><code>source/_draft</code></td></tr><tr><td>自定义</td><td><code>source/_post</code></td></tr></tbody></table></li></ul></li><li><p><code>source</code>：博客文章的.md文件。除<code>\_post</code>文件夹外，开头以<code>_</code>（下划线）命名的文件/文件夹或隐藏文件都会在generate时被忽略。</p></li><li><p><code>themes/</code>：主题文件夹</p></li><li><p><code>.gitignore</code>：限定在push时哪些文件可以忽略</p></li><li><p><code>_config.yml</code>：站点的配置文件。配置参数参考：<a href="https://hexo.io/zh-cn/docs/configuration">Hexo配置参数说明</a></p></li><li><p><code>db.json</code>：<code>hexo g</code> 生成的文件</p></li><li><p><code>package.json</code>：应用程序信息，包括hexo的版本信息和所有安装的依赖</p></li><li><p><code>.git/</code>：标志这是一个git项目</p></li><li><p><code>public</code>：<code>hexo g</code> 生成的静态网页</p></li></ul><blockquote><p>总结下，需要备份的文件有：<code>scaffolds/</code>、<code>source</code>、<code>themes/</code>、<code>_config.yml</code>、<code>package.json</code>、<code>.gitignore</code></p></blockquote><h3 id="2-2-Hexo指令参考"><a href="#2-2-Hexo指令参考" class="headerlink" title="2.2 Hexo指令参考"></a>2.2 Hexo指令参考</h3><p><code>$ hexo init [folder]</code></p><ul><li>新建一个网站根目录，进行初始化。</li></ul><p><code>$ hexo clean</code></p><ul><li>清除缓存文件 (db.json) 和已生成的静态文件 (public)。如果发现对站点的更改无法生效，可能需要运行该命令。</li></ul><p><code>$ hexo new [layout] &lt;title&gt;</code></p><ul><li>新建一篇文章，标题含有空格的话需要用单/双引号括起来。</li><li>layout：文章布局。默认由 _config.yml 中的 default_layout 参数指定</li><li>参数：<ul><li>-p, –path        自定义新文章的路径（默认情况下会解析标题来确定路径）</li><li>-r, –replace    如果存在同名文章，将其替换</li><li>-s, –slug        文章的 Slug，作为新文章的文件名和发布后的 URL</li></ul></li></ul><p><code>$ hexo generate/g</code></p><ul><li><p>生成静态文件。（将souce文件夹下的Markdown和HTML文件解析到了public文件夹下）</p></li><li><p>参数：</p><ul><li><p>-d, –deploy    文件生成后立即部署网站</p></li><li><p>-w, –watch        监视文件变动</p></li><li><p>-b, –bail        生成过程中如果发生任何未处理的异常则抛出异常</p></li><li><p>-f, –force        强制重新生成文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</p></li><li><p>-c, –concurrency    最大同时生成文件的数量，默认无限制</p></li></ul></li></ul><p><code>$ hexo publish [layout] &lt;filename&gt;</code></p><ul><li>发表草稿。草稿默认不会显示在页面中。</li></ul><p><code>$ hexo server/s</code></p><ul><li><p>启动服务器。默认情况下，访问网址为：<a href="http://localhost:4000/">http://localhost:4000/</a></p></li><li><p>参数：</p><ul><li>-p, –port    重设端口</li><li>-s, –static    只使用静态文件</li><li>-l, –log    启动日记记录，使用覆盖记录格式</li></ul></li></ul><p><code>$ hexo deploy/d</code></p><ul><li>部署网站。（将本地资源部署到服务器，我这里也就是GithubPages中）</li><li>参数：-g, –generate    部署之前预先生成静态文件</li></ul><p><code>$ hexo render &lt;file1&gt; [file2] ...</code></p><ul><li>渲染文件。</li><li>参数：-o, –output    设置输出路径</li></ul><p><code>$ hexo migrate &lt;type&gt;</code></p><ul><li>从其他博客系统迁移内容。可从RSS、Jekyll、Octopress、WordPress、Joomla中迁移，具体参考 <a href="https://hexo.io/zh-cn/docs/migration">博客迁移</a></li></ul><p><strong>选项：</strong></p><p><code>$ hexo --safe</code></p><ul><li>安全模式。不会载入插件和脚本。在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</li></ul><p><code>$ hexo --debug</code></p><ul><li>调试模式。在终端中显示调试信息并记录到 debug.log。</li></ul><p><code>$ hexo --silent</code></p><ul><li>简洁模式。隐藏终端信息。</li></ul><p><code>$ hexo --draft</code></p><ul><li>显示 source/_drafts 文件夹中的草稿文章。</li></ul><p><code>$ hexo --cwd /path/to/cwd</code></p><ul><li>自定义当前工作目录（Current working directory）的路径。</li></ul><h2 id="3-将静态文件部署到对应的仓库中"><a href="#3-将静态文件部署到对应的仓库中" class="headerlink" title="3. 将静态文件部署到对应的仓库中"></a>3. 将静态文件部署到对应的仓库中</h2><ol><li><p>打开站点根目录中的 <code>_config.yml</code> 文件，找到deploy字段（在最下面），将其用以下内容替换：</p><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><span class="hljs-attr">type:</span> <span class="hljs-string">git</span><span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:username/username.github.io.git</span><span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></li><li><p>安装插件（注意要在站点根目录下执行该操作）：<code>$ npm install hexo-deployer-git --save</code></p></li><li><p>部署： <code>$ hexo deploy</code>（建议执行该步前先 <code>$ hexo clean</code>）</p></li></ol><br><hr><h1 id="二、内容管理"><a href="#二、内容管理" class="headerlink" title="二、内容管理"></a>二、内容管理</h1><blockquote><p>博客发布的内容都位于 <code>source/_post/</code> 文件夹中。</p></blockquote><ol><li>创建新文章：<code>$ hexo new &#39;title&#39;</code></li><li>创建成功后会发现 <code>source/_post/</code> 中多了一篇相同标题的<code>.md</code>文件，打开该文件编辑即可</li><li>编辑完成发布：<code>$ hexo g -d</code></li></ol><p>也可以在<code>source/_post/</code>目录下手动创建<code>.md</code>文件，但这时就需要你自己手动复制一下poster：</p><pre><code class="hljs html">---title: date: tags: categories: ---</code></pre><p>删除文件则直接在文件夹内手动删除然后重新部署就好了。</p><br><hr><h1 id="三、主题修改"><a href="#三、主题修改" class="headerlink" title="三、主题修改"></a>三、主题修改</h1><blockquote><p>我本人使用的是 landscape 主题，不过你可以挑选任何你喜欢的主题<a href="https://hexo.io/themes/">主题商城</a>，我这里建议使用 NexT 主题，因为它的各方面插件都比较完善不需要费太多时间。</p></blockquote><p>修改主题步骤：</p><ol><li>下载主题文件夹到/themes/目录下</li><li>修改站点配置文件中的theme字段，e.g.  <pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">landscape</span></code></pre></li></ol><hr><h1 id="四、检索配置"><a href="#四、检索配置" class="headerlink" title="四、检索配置"></a>四、检索配置</h1><h2 id="1-配置sitemap文件"><a href="#1-配置sitemap文件" class="headerlink" title="1. 配置sitemap文件"></a>1. 配置sitemap文件</h2><ol><li><p>在站点根目录下输入以下命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install hexo-generator-sitemap —save</span><span class="hljs-meta">$</span><span class="bash"> npm install hexo-generator-baidu-sitemap —save </span></code></pre></li><li><p>在站点根目录的配置文件_cpnfig.yml中添加：</p><pre><code class="hljs yaml"><span class="hljs-comment"># sitemap</span><span class="hljs-attr">sitemap:</span><span class="hljs-attr">path:</span> <span class="hljs-string">sitemap.xml</span><span class="hljs-attr">baidusitemap:</span><span class="hljs-attr">path:</span> <span class="hljs-string">baidusitemap.xml</span></code></pre></li><li><p>执行：<code>$ hexo g</code><br>public文件夹下多了 <strong>sitemap.xml</strong> 和 <strong>baidusitemap.xml</strong> 两个文件，这就是供搜索Google和百度引擎爬虫抓取的站点地图。</p></li></ol><h2 id="2-Google站点验证"><a href="#2-Google站点验证" class="headerlink" title="2. Google站点验证"></a>2. Google站点验证</h2><ol><li>进入 <a href="https://www.google.com/webmasters/tools/">Google站点管理工具</a> ，选择网址前缀，在网址中输入你的博客地址。</li><li>下载HTML文件，将文件放到站点根目录下的 <code>/public</code> 文件夹中</li><li>执行 <code>$ hexo d</code></li><li>等待一分钟左右，返回Google页面点击验证</li><li>验证成功后再次回到  <a href="https://www.google.com/webmasters/tools/">Google站点管理工具</a>  。在右侧工具栏中找到 <strong>站点地图</strong> 选项。</li><li>在界面中输入 <strong>sitemap的存放路径</strong>。因为public为站点的实际根目录，所以输入的是 <code>sitemap.xml</code></li><li>等待一段时间即可通过Google检索到</li></ol><blockquote><p>注意这里Google会先显示站点地图无法获取，但其实后台已经在处理了，大概等1~2天就能检索到。</p></blockquote><h2 id="3-百度站点验证"><a href="#3-百度站点验证" class="headerlink" title="3. 百度站点验证"></a>3. 百度站点验证</h2><p>参考：<a href="https://www.cnblogs.com/lfri/p/12219639.html">https://www.cnblogs.com/lfri/p/12219639.html</a></p><br><hr><h1 id="五、遇到的问题＆总结"><a href="#五、遇到的问题＆总结" class="headerlink" title="五、遇到的问题＆总结"></a>五、遇到的问题＆总结</h1><ol><li>频繁在修改网站资源需要预览时使用 <code>hexo s</code> 先在本地调试，直接部署的话太慢了，刷新记得 <code>ctrl+F5</code></li><li>如果用vscode编辑配置文件，要进行部署的时候记得在vscode把文件先关闭，不然会报错</li></ol><br><br><br><hr><blockquote><p>参考链接：</p><p><a href="https://sketchk.xyz/2017/03/24/A-Guide-Of-Making-Your-Personal-Blog-Part-1/">https://sketchk.xyz/2017/03/24/A-Guide-Of-Making-Your-Personal-Blog-Part-1/</a></p><p><a href="https://juejin.im/post/6844904131266609165#heading-18">https://juejin.im/post/6844904131266609165#heading-18</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下简单流程和出现的问题。&lt;/p&gt;</summary>
    
    
    <content src="https://cdn.jsdelivr.net/gh/Drrany/PicBed/images_blog/20200816213131.png" type="image"/>
    
    
    <category term="配置" scheme="http://drrany.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="Hexo" scheme="http://drrany.github.io/tags/Hexo/"/>
    
    <category term="记录" scheme="http://drrany.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
