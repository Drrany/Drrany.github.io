<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2021.3月PAT经历(甲级满分)</title>
    <link href="/PAT/"/>
    <url>/PAT/</url>
    
    <content type="html"><![CDATA[<h2 id="个人准备"><a href="#个人准备" class="headerlink" title="个人准备"></a>个人准备</h2><p>先说一下个人情况，我是科班，没参加过竞赛，上过算法课，自己去年也刷过200+LeetCode题，不过忘得差不多了……。加上自己之前主要用Java刷题，没学过C++，我觉得语言的熟悉程度挺重要的，有时候解法能有很多小trick，所以刚开始PAT总觉得不顺手(实在不敢用Java挑战超时)</p><p>学校一月份放了寒假，差不多回家就开始准备了。</p><p>一开始是跟着晴神的算法笔记做，每天大概学习两个小时左右(带刷题)，刷完算法笔记用了一个月吧，主要是一天分配时间太少了……想着后期努力。书看完之后开始自己独立刷题，一天大概也是两个小时5、6道，因为一边刷一边学。一般一道题卡快一个小时就开始找题解了，因为pat本质上出题都很模板，考得不光是你的能力，也是你对这些常用算法的熟悉程度(并查集、Dijsktra、堆等等)，所以不要一个人死耗，一道题看个一两天做出来了觉得自己很牛逼……其实是浪费时间，而且一定要学习别人的优质代码是怎么写的，一道题可能你也做出来了，但是耗时高，写的代码多(写得多就容易出bug)。</p><p>这里说下我觉得PAT高分最重要的不是天分，而是积累，只要你常用算法模板非常熟悉，在上面的小小变形是不成问题的，根基都没打牢的话高分只能看运气(恰好出了你会的题)。我建议刷题的过程中积累一些常见模板，比如怎么通过中序、前序/后序遍历构建二叉树，Dijsktra+DFS的套路等等，最重要的是你平时自己能写出来这套模板，背是不现实的，只有是你自己的东西才是记得最牢的。</p><p>PAT甲的真题我基本上刷了两遍，个人觉得后期的题参考价值比较大，不过时间够的前面刷刷也可以开阔思路~刷的多总是没错的。</p><p>考前两天做了20、19年的六套(春秋冬季)甲级卷，分数分别是94、92、93和100(19年三套都比较简单)，我觉得这几次模拟做对我的作用很大，因为第一套卷子我就一直卡题，全程做的很艰难，我还记得第一次过完四道题好像才七八十分，心里很凉，但是时间还多，就开始一个一个找bug(pat的时间还是很良心的)，最后努力到了90+，这次对我的心理素质提升非常大，因为觉得这么难搞的开局我都能90+，考试也不至于比这还差吧（这是个flag，谁想到考试开局比这还离谱……）</p><p>哦对了，PAT最重要的是一定要完全读懂题！！！完全！！！很多次过不去点是因为你漏了条件或者题读得有问题……这点真的很重要！！！</p><p>我的PAT代码都放在github仓库上了，不过有些没有优化，仅供参考：<a href="https://github.com/Drrany/Algorithms_Code/tree/master/C%26C%2B%2B/PAT">PAT代码</a></p><h2 id="考试经过"><a href="#考试经过" class="headerlink" title="考试经过"></a>考试经过</h2><p>大概提前了快两个小时交卷，这次题不算很简单但也不坑，基本上认真看懂题都能AC。<br>趁着还记得来记录下这次波折的线上PAT经历……。</p><p>这次1:30开考，我12:40开始折腾设备。双机位考试，拍照和视频倒是被监考老师通过了，但是手机那边一直显示连接失败，我一开始不知道什么问题，再加上两边显示正常，就没有管。一直按着“呼叫监考老师”想问问老师怎么办，无奈可能是人太多了，根本没有老师管你……最后开考前20分钟，老师说我手机摄像头是黑的，我又四处问人，发现可能是手机权限问题(?)，但是当时还剩10分钟左右了，不管怎么搞都还是没办法连通。<br>幸好父上大人在家，飞速争用了他的手机，重新登录我的微信，各种重新验证，最后两分钟了我还在填准考证号和拍验证视频……。</p><p>而且这次最难AC的还是第一道题，我第一道题做了块40分钟还没AC，有两个测试点不过，就先跳过了。</p><p>经过这个开头我的心情一直是很down的，最后能AK还是多亏了自己的心理素质，一直在给自己打气。考试的时候你的能力决定你的上限，但是心理素质决定你的下限。<br>下面依次来说一下每道题吧~因为现在题目还没出，可能描述有些出入（老失忆大师了）</p><h2 id="简单题解"><a href="#简单题解" class="headerlink" title="简单题解"></a>简单题解</h2><h3 id="1-等差质数"><a href="#1-等差质数" class="headerlink" title="1. 等差质数"></a>1. 等差质数</h3><p>题目大意是给一个数n和范围range，让你找n个质数组成的等差数列(都不大于range)，如果不唯一就找差最大的，还不唯一就找第一个数字最大的。找不到就输出不大于range的最大素数。</p><p>我的方法比较暴力，先得到 $10^5$ 以内的素数表。然后遍历素数表，先确定前两个素数，这样就得到了他们的差，再找剩下n-2个素数，这就比较简单了，每次用前一个素数加上差，看得到的下一个数是不是素数就行了。<br>得到一个新答案就比较一下，最后输出。</p><p>这里我n=1特判了一下。以及第一次有两个点没AC是因为我用的&lt;range，改成&lt;=range就过了……。</p><h3 id="2-实验室使用安排"><a href="#2-实验室使用安排" class="headerlink" title="2. 实验室使用安排"></a>2. 实验室使用安排</h3><p>这个感觉不用多说了……经典贪心问题，学过就会，没学过就抓瞎(或者上dfs，基本上确定顺序都能用，就是容易超时，要剪好枝)。</p><p>先按结束时间从小到大排序，然后依次遍历每条记录，如果当前记录的进入时间大于上一个人的结束时间，那这个人就可以进入，然后更新结束时间。</p><h3 id="3-大顶堆"><a href="#3-大顶堆" class="headerlink" title="3. 大顶堆"></a>3. 大顶堆</h3><p>体感是这次最难的一道题，虽然做的时间和第一题差不多，但主要是因为考前出事心态问题。幸好考前重新做了一遍堆排序题。</p><p>这题的主要难点是通过插入的值得到正确的树，只要构造出了正确的树，后面的父母孩子啥的都很好判断，直接用完全二叉树的特性第i个结点的孩子是第2i和第2i+1就行了。<br>我一开始是得到了所有的值，然后再直接调整，但是这样得到的树和样例不一样，最后发现得插入一次调整一次……这代码还没删，贴一下：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> n)</span> </span>&#123;     <span class="hljs-keyword">int</span> index = <span class="hljs-number">2</span> * i;    <span class="hljs-keyword">if</span> (index &gt; n) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &lt;= n &amp;&amp; (arr[index + <span class="hljs-number">1</span>] &gt; arr[index])) index++;    <span class="hljs-keyword">if</span> (arr[index] &gt; arr[i]) &#123;        swap(arr[i], arr[index]);        adjust(arr, index, n);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toMaxHeap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;tree, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123; <span class="hljs-comment">// 自下向上构造一个大顶堆</span>        adjust(tree, i, n);     &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> n, m;    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tree;    <span class="hljs-keyword">int</span> num;    tree.push_back(INT32_MAX);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;        <span class="hljs-built_in">cin</span> &gt;&gt; num;        tree.push_back(num);        <span class="hljs-comment">// 调整tree[1..i]为大顶堆</span>        toMaxHeap(tree, i);    &#125;    <span class="hljs-comment">// </span>&#125;</code></pre><h3 id="4-回收共享单车"><a href="#4-回收共享单车" class="headerlink" title="4. 回收共享单车"></a>4. 回收共享单车</h3><p>基本上是个多源最短路径问题。要求从0点出发经过每个点，下个点是距离当前最近的点，得到这个序列，并且判断出哪些点不可达。</p><p>所以我选择了Floyd，先求出每两个点之间的最短距离，直接迭代n次，每次找出还没到过的点中最近的那个，如果找不到了就跳出循环，说明之后的点都无法到达了。<br>其他也没什么好说的，这道题也是一次AC。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次PAT的题目还是比较良心的，虽然自己的过程十分不顺利，好在最后的结果还不错，只能说一分耕耘一分收获，满打满算快两个月每天都有两个小时在PAT上，之后可能不会再碰了，圆满结束~<br>贴一下截图~<br><img src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20210313-185600-0538.png"></p><hr><p>具体代码忘了保存等能查的时候再贴~</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法总结和LeetCode题目实践</title>
    <link href="/ShortestPathAlgorithm/"/>
    <url>/ShortestPathAlgorithm/</url>
    
    <content type="html"><![CDATA[<blockquote><p>常见的最短路径算法总结。</p></blockquote><a id="more"></a><h1 id="最短路径算法总结和-LeetCode-题目实践"><a href="#最短路径算法总结和-LeetCode-题目实践" class="headerlink" title="最短路径算法总结和 LeetCode 题目实践"></a>最短路径算法总结和 LeetCode 题目实践</h1><p>最近复习到了图相关，总结了最短路径问题的几个常用算法（Dijsktra 算法、Floyd 算法、Bellman-Ford 算法、SPFA 算法）。给出了具体题目实现。</p><p>给定图 G(V,E)，共有 n 个顶点：</p><h2 id="Dijsktra-算法"><a href="#Dijsktra-算法" class="headerlink" title="Dijsktra 算法"></a>Dijsktra 算法</h2><p>通常用于计算单源最短路径问题，即给定源点<code>src</code>，计算其他每个顶点到源点的最短距离。（注意：Dijsktra 不能解决边权有负值的情况）</p><p><strong>基本思想</strong>：设置一个顶点集合 S，存放已找到最短路径的顶点，每次从 V-S 集合中找距离源点距离最小的点，假设为<code>u</code>，将其加入集合 S。再次遍历 V-S 集合中的点，设为<code>v</code>，看是否能对边<code>(u,v)</code>进行松弛操作(<code>dist[u]+G[u][v]&lt;dist[v]</code>)。</p><p><strong>伪代码</strong>：</p><pre><code class="hljs c++"><span class="hljs-comment">// 设置的数据结构：</span><span class="hljs-keyword">bool</span> visited[n]; <span class="hljs-comment">// visited[i]=true表示顶点i已经加入集合S</span><span class="hljs-keyword">int</span> dist[n]; <span class="hljs-comment">// dist[i]表示顶点i距离源点的最短距离</span><span class="hljs-keyword">int</span> pre[n];     <span class="hljs-comment">// 到达pre[i]的最短路径上，i的前一个顶点</span>遍历n次：    找出V-S中距离源点最近的点，记为u    若不存在，说明G不是连通图    visited[u]=<span class="hljs-literal">true</span>    遍历V-S中所有点v    若dist[u]+G[u][v]&lt;dist[v]：    更新dist[v]和pre[v]</code></pre><p>例：</p><ol><li><p><a href="https://leetcode-cn.com/problems/network-delay-time/">LeetCode-743.网络延迟时间</a></p><ul><li><p>思路：计算源点到其他所有点所需的时间，记录在数组 dist[]中，返回 dist[]中的最大值，即延迟时间</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;times, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">// 将times转换为邻接矩阵G</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">G</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, INT32_MAX))</span></span>;        <span class="hljs-keyword">int</span> len = times.<span class="hljs-built_in">size</span>(), ui, vi, wi;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;            ui = times[i][<span class="hljs-number">0</span>], vi = times[i][<span class="hljs-number">1</span>], wi = times[i][<span class="hljs-number">2</span>];            G[ui][vi] = wi;        &#125;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT32_MAX)</span></span>; <span class="hljs-comment">// 到源点的距离</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// 是否加入集合S</span>        dist[k] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 遍历n次</span>            <span class="hljs-comment">// 找出集合V-S中距离源点最近的</span>            <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, minDist = INT32_MAX;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;                <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;                    u = j;                    minDist = dist[j];                &#125;            &#125;            <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;   <span class="hljs-comment">// 若未找到，返回-1</span>            visited[u] = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 将u加入集合S</span>            <span class="hljs-comment">// 用顶点u更新V-S中其他顶点的最短距离</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) &#123;                <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INT32_MAX)                    dist[v] = <span class="hljs-built_in">min</span>(dist[v], dist[u] + G[u][v]);            &#125;        &#125;        <span class="hljs-keyword">return</span> *max_element(dist.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, dist.<span class="hljs-built_in">end</span>());    &#125;&#125;;</code></pre></li></ul></li><li><p><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">LeetCode-787. K 站中转内最便宜的航班</a></p><ul><li><p>思路：使用优先队列+Dijsktra 算法。记录到达每个结点(城市)处的中转次数和花费，优先操作花费最少的结点。</p>   <pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">City</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> index; <span class="hljs-comment">// 城市编号</span>    <span class="hljs-keyword">int</span> cost;  <span class="hljs-comment">// 花费</span>    <span class="hljs-keyword">int</span> hop;   <span class="hljs-comment">// 到达该城市的中转次数</span>City(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> h) &#123;    index = i, cost = c, hop = h;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> City &amp;a, <span class="hljs-keyword">const</span> City &amp;b) &#123;        <span class="hljs-keyword">return</span> a.cost &gt; b.cost;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;flights, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dst, <span class="hljs-keyword">int</span> K)</span> </span>&#123;        <span class="hljs-comment">// 将flights转换为邻接矩阵</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">G</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, INT32_MAX))</span></span>;        <span class="hljs-keyword">int</span> len = flights.<span class="hljs-built_in">size</span>(), ui, vi, wi;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;            ui = flights[i][<span class="hljs-number">0</span>], vi = flights[i][<span class="hljs-number">1</span>], wi = flights[i][<span class="hljs-number">2</span>];            G[ui][vi] = wi;        &#125;        <span class="hljs-comment">// 创建优先队列，花费少的结点优先</span>        <span class="hljs-built_in">priority_queue</span>&lt;City&gt; pq;        pq.push(City(src, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));        <span class="hljs-keyword">while</span> (!pq.empty()) &#123;            City t = pq.top();            pq.pop();            <span class="hljs-keyword">if</span> (t.hop &gt; K + <span class="hljs-number">1</span>) <span class="hljs-comment">// k站中转，hop最大可以等于K+1</span>                <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">int</span> u = t.index, c = t.cost, h = t.hop;            <span class="hljs-keyword">if</span> (u == dst)   <span class="hljs-comment">// 若能到达目的地，则一定是最优花费的</span>                <span class="hljs-keyword">return</span> c;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; ++v) &#123;                <span class="hljs-keyword">if</span> (G[u][v] != INT32_MAX)                    pq.push(City(v, G[u][v] + c, h + <span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre></li></ul></li></ol><h3 id="Dijsktra-算法-DFS"><a href="#Dijsktra-算法-DFS" class="headerlink" title="Dijsktra 算法+DFS"></a>Dijsktra 算法+DFS</h3><p>上面两道题都没有要求输出具体的最短路径，所以没有使用 pre 数组。有两种稍微复杂的情况如下：</p><ol><li>源点到某个点的最短路径不止一条</li><li>不光要求从源点到其他点的距离最短，还有其他最优要求（e.g. 每个点有一个属性值，要求总属性值最大/小）</li></ol><p>第一个问题可以通过将 pre 数组修改为<code>vector&lt;vecotr&lt;int&gt; &gt;pre</code>，然后对<code>pre</code>进行 DFS 得到每条路径。</p><p>第二个问题，如果最优要求比较简单，可以直接在原有 Dijsktra 算法上修改，如果比较麻烦，可以先求出所有最短路径，再通过 DFS 对每条路径的属性进行比较，得到要求解。</p><p>例：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">PAT-1003.Emergency</a></p><ul><li><p>思路：该题中不仅要求距离最短，还要求所有最短路径中，输出救援队人数最多的那条（也就是路径经过的所有城市点权相加）</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> maxSum = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> ansNum = <span class="hljs-number">0</span>;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; curPath;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; pre, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; w, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> src)</span> </span>&#123;    <span class="hljs-keyword">if</span> (u == src) &#123;        ansNum++;        curPath.push_back(u);        <span class="hljs-comment">// 计算救援队总人数</span>        <span class="hljs-keyword">int</span> len = curPath.<span class="hljs-built_in">size</span>(), curSum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)            curSum += w[curPath[i]];        maxSum = <span class="hljs-built_in">max</span>(maxSum, curSum);        curPath.pop_back();        <span class="hljs-keyword">return</span>;    &#125;    curPath.push_back(u);    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; last = pre[u];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; last.<span class="hljs-built_in">size</span>(); ++i)        dfs(pre, w, last[i], src);    curPath.pop_back();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> n, m, src, dst;    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; src &gt;&gt; dst;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(n)</span></span>;   <span class="hljs-comment">// 每个城市的救援队人数</span>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">G</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, INT32_MAX))</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)        <span class="hljs-built_in">cin</span> &gt;&gt; w[i];    <span class="hljs-keyword">int</span> ui, vi, wi;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;        <span class="hljs-built_in">cin</span> &gt;&gt; ui &gt;&gt; vi &gt;&gt; wi;        G[ui][vi] = G[vi][ui] = wi;    &#125;    <span class="hljs-comment">// 先单纯使用Dijsktra算法计算出所有最短路径</span>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, INT32_MAX)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;())</span></span>;    dist[src] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, minDist = INT32_MAX;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;                u = j;                minDist = dist[j];            &#125;        &#125;        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        visited[u] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; ++v) &#123;            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INT32_MAX) &#123;                <span class="hljs-keyword">int</span> tmp = G[u][v] + dist[u];                <span class="hljs-keyword">if</span> (tmp &lt; dist[v]) &#123;    <span class="hljs-comment">// 更新最短路径</span>                    dist[v] = tmp;                    pre[v].<span class="hljs-built_in">clear</span>();                    pre[v].push_back(u);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp == dist[v])                    pre[v].push_back(u);            &#125;        &#125;    &#125;    <span class="hljs-comment">// DFS得到最短路径条数和救援队最大人数</span>    dfs(pre, w, dst, src);    <span class="hljs-built_in">cout</span> &lt;&lt; ansNum &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; maxSum;&#125;</code></pre></li></ul><h2 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h2><p>Floyd 算法可以用来解决多源最短路径问题，它会计算图中每两个点之间的最短路径。</p><p><strong>基本思想</strong>：如果令 k 作为顶点 i 和 j 之间路径的中介点能够得到一条更短的路径，则令 k 作为其最短路径的中介点。</p><p><strong>伪代码</strong>：(由伪代码可知 Floyd 算法的复杂度为 $O(n^3)$ ，所以通常用于图点数不太大的情况)</p><pre><code class="hljs c++"><span class="hljs-comment">// dist[i][j]表示顶点i和j之间的最短距离</span><span class="hljs-function"><span class="hljs-keyword">for</span> k <span class="hljs-title">in</span> <span class="hljs-params">(<span class="hljs-number">1</span>,n)</span>:<span class="hljs-comment">// 令每个点分别作为中介点进行测试</span></span><span class="hljs-function"><span class="hljs-keyword">for</span> i <span class="hljs-title">in</span> <span class="hljs-params">(<span class="hljs-number">1</span>,n)</span>:</span><span class="hljs-function"><span class="hljs-keyword">for</span> j <span class="hljs-title">in</span> <span class="hljs-params">(<span class="hljs-number">1</span>,n)</span>:</span>if dist[i][j]&gt;dist[i][k]+dist[k][j]:dist[i][j]=dist[i][k]+dist[k][j]</code></pre><ul><li>注意一下这里的 k，也就是枚举的中介点必须在最外层才能保证这个贪心的正确性。因为 Floyd 算法的本质是 DP，也就是说<code>dist[k][i][j]=min(dist[k-1][i][j],dist[k-1][i][k]+dist[k-1][k][j])</code>，如果 k 不在最外层就不能保证当计算到 k 时，所有 k-1 的值都是最优的。</li></ul><p><strong>例：</strong> <a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">LeetCode-1334. 阈值距离内邻居最少的城市</a></p><ul><li><p>思想：用 Floyd 算法计算出每两个城市之间的最短距离，然后分别遍历每个城市，计算满足要求的邻居数量，返回邻居最少的城市。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTheCity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;edges, <span class="hljs-keyword">int</span> distanceThreshold)</span> </span>&#123;        <span class="hljs-comment">// 初始化邻接矩阵，也作为距离矩阵dist</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, INT32_MAX))</span></span>;        <span class="hljs-keyword">int</span> len = edges.<span class="hljs-built_in">size</span>(), ui, vi, wi;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;            ui = edges[i][<span class="hljs-number">0</span>], vi = edges[i][<span class="hljs-number">1</span>], wi = edges[i][<span class="hljs-number">2</span>];            dist[ui][vi] = dist[vi][ui] = wi;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-comment">// 将到自身的距离初始化为0，下面的遍历中就不需要对kij三个点中有相等情况时的特殊处理</span>            dist[i][i] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;                    <span class="hljs-keyword">if</span> (dist[i][k] &lt; INT32_MAX &amp;&amp; dist[k][j] &lt; INT32_MAX &amp;&amp; (dist[i][k] + dist[k][j] &lt; dist[i][j]))                        dist[i][j] = dist[i][k] + dist[k][j];                &#125;            &#125;        &#125;        <span class="hljs-comment">// 找出满足条件邻居最少的城市</span>        <span class="hljs-keyword">int</span> ansCity, ansNum = INT32_MAX;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">int</span> tmpNum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;                <span class="hljs-keyword">if</span> (dist[i][j] &lt;= distanceThreshold)                    tmpNum++;            &#125;            <span class="hljs-keyword">if</span> (tmpNum &lt;= ansNum) &#123;                ansNum = tmpNum;                ansCity = i;            &#125;        &#125;        <span class="hljs-keyword">return</span> ansCity;    &#125;&#125;;</code></pre></li></ul><h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>Bellman-Ford 算法也是解决单源最短路径，其还可以处理有负边权的图。</p><p>首先要明确一点，在带有负边权的图中，不能有源点可达的负环，否则当从源点出发，将该负环循环走无数次，路径值会越来越小，也就不存在最短路径。所以当图中存在从源点可达的负环时，函数要返回 false。</p><p><strong>思路</strong>：将图 G 中的所有边，遍历 n-1 次。对于边<code>(u,v,w)</code>，若<code>dist[u]+w&lt;dist[v]</code>，则更新<code>dist[v]</code>。</p><ul><li><u>为什么要遍历所有边</u>：第 i 次遍历，其实是确定其他点分别到源点的最短路径上，第 i 个顶点是谁，也可以说是经过的第 i 条边是谁。</li><li><u>为什么要遍历 n-1 次</u>：在每个顶点到源点的最短路径上，顶点数最多为 n 个，除非有负环，所以最多只需要遍历 n-1 次(第一个顶点已经确定下来了)，就可以确定所有顶点的最短路径。</li></ul><p><strong>伪代码</strong>：</p><pre><code class="hljs c++">遍历n<span class="hljs-number">-1</span>次：    对每条边(u,v,w)：    dist[v]=<span class="hljs-built_in">min</span>(dist[v],dist[u]+w)<span class="hljs-comment">// 再遍历一次判断是否存在负环</span>对每条边(u,v,w)：    <span class="hljs-keyword">if</span> dist[u]+w&lt;dist[v]:<span class="hljs-comment">// 若数组中还有未达到最优的值，只能说明图中有负环，返回false</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</code></pre><ul><li>在某次遍历中，如果所有的 dist 值都没有被优化，说明 dist 中所有值已经达到最优，可以直接退出循环。</li><li>如果要记录最短路径，可以设置一个<code>set&lt;int&gt; pre</code>，因为每次遍历会反复访问重复的点，而 set 可以自行去重。</li></ul><p><strong>例：</strong></p><ol><li><p><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">LeetCode-787. K 站中转内最便宜的航班</a></p> <pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;flights, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dst, <span class="hljs-keyword">int</span> K)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, INT32_MAX)</span></span>;        dist[src] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len = flights.<span class="hljs-built_in">size</span>();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(dist)</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K + <span class="hljs-number">1</span>; ++i) &#123; <span class="hljs-comment">// K次中转，可以经过K+1条边</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j) &#123; <span class="hljs-comment">// 遍历每条边</span>                <span class="hljs-keyword">int</span> u = flights[j][<span class="hljs-number">0</span>], v = flights[j][<span class="hljs-number">1</span>], w = flights[j][<span class="hljs-number">2</span>];                <span class="hljs-keyword">if</span> (dist[u] &lt; INT32_MAX)                    copy[v] = <span class="hljs-built_in">min</span>(copy[v], dist[u] + w);    <span class="hljs-comment">// 更新在copy上是为了防止在一次遍历中多次修改dist[i]的值，则其不止确定了一条边</span>            &#125;            dist = copy;        &#125;        <span class="hljs-keyword">return</span> dist[dst] == INT32_MAX ? <span class="hljs-number">-1</span> : dist[dst];    &#125;&#125;;</code></pre></li><li><p><a href="https://leetcode-cn.com/problems/path-with-maximum-probability/">LeetCode-1514.概率最大的路径</a></p><ul><li><p>思路：这题咋一看有点唬人，其实也满足贪心策略，因为他要找的是最大相乘边权路径，而每个边权大小 ∈[0,1]，随着路径上边数的增加，边权只会越来越小，所以用 Bellman-Ford 算法时，最先得到的最大路径一定是最优解。</p>  <pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">maxProbability</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;edges, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; &amp;succProb, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = edges.<span class="hljs-built_in">size</span>();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">prob</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;        prob[start] = <span class="hljs-number">1.0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;            <span class="hljs-keyword">bool</span> isChange = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j) &#123;                <span class="hljs-keyword">int</span> u = edges[j][<span class="hljs-number">0</span>], v = edges[j][<span class="hljs-number">1</span>];                <span class="hljs-keyword">double</span> w = succProb[j];                <span class="hljs-keyword">if</span> (prob[u] * w &gt; prob[v]) &#123;                    prob[v] = prob[u] * w;                    isChange = <span class="hljs-literal">true</span>;                &#125;                <span class="hljs-keyword">if</span> (prob[v] * w &gt; prob[u]) &#123;                    prob[u] = prob[v] * w;                    isChange = <span class="hljs-literal">true</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (!isChange)                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> prob[<span class="hljs-built_in">end</span>];    &#125;&#125;;</code></pre></li></ul></li></ol><h2 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="SPFA 算法"></a>SPFA 算法</h2><p>SPFA 算法是基于 Bellman-Ford 算法改进得到的。B-F 算法每次边遍历，要对所有边都进行一次操作，但其实哪些边需要进行操作是可以提前确定的：只有当某个顶点 u 的 dist[u]值改变时，从他出发的边(u,v)才需要进行操作，因为只有此时顶点 v 的值才可能改变。</p><p><strong>基本操作：</strong>使用队列来存储 dist 值改变的点。每次取队首的顶点，然后对该顶点的所有边进行操作，如果边的另一个顶点的 dist 值改变，则将该顶点加入到队列中（如果该顶点当前不在队列中）。这样一直到队列为空。</p><ul><li>如果图中存在从源点可达的负环，则可能存在顶点无限次入队，使得队列不可能为空，这时用一个数组来记录每个顶点的入队次数，当一个顶点入队次数超过 n-1 时，返回 false。</li></ul><p><strong>伪代码：</strong></p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; in;<span class="hljs-comment">// 标记顶点是否在队列中</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; count;<span class="hljs-comment">// 记录顶点的入队次数</span><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;q.push(src);<span class="hljs-comment">// 源点入队</span><span class="hljs-keyword">while</span>(!q.empty())&#123;    <span class="hljs-keyword">int</span> u = q.pop();    in[u] = <span class="hljs-literal">false</span>;    对u的每条边进行松弛操作：        若v的dist值改变且!in[v]：        q.push(v);    count[v]++;    in[v] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span> count[v]&gt;n<span class="hljs-number">-1</span>:    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>例：</p><ol><li><p><a href="https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/">LeetCode-1129.颜色交替的最短路径</a></p><ul><li><p>思路：每个结点处添加颜色信息，以实现交替查找不同颜色的边。由于每个点可能多次访问，但是边不能重复访问，所以设置一个边访问表来记录边的访问情况。只要当前边没有访问过，就可以新建结点入队，这样保证了能得到所有解。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> color;  <span class="hljs-comment">// 0表示由一条红边到该点，1表示由一条蓝边到该点</span>    <span class="hljs-keyword">int</span> vertex; <span class="hljs-comment">// 顶点编号</span>    <span class="hljs-keyword">int</span> len;    <span class="hljs-comment">// 长度</span>    Node(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> l) &#123;        color = c;        vertex = v;        len = l;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shortestAlternatingPaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;red_edges, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;blue_edges)</span> </span>&#123;        <span class="hljs-comment">// 建立邻接表和边访问表</span>        vector&lt;vector&lt;int&gt;&gt; redAdj(n, vector&lt;int&gt;()), blueAdj(n, vector&lt;int&gt;());        vector&lt;vector&lt;bool&gt;&gt; redVis(n, vector&lt;bool&gt;()), blueVis(n, vector&lt;bool&gt;());        <span class="hljs-keyword">int</span> redNum = red_edges.<span class="hljs-built_in">size</span>(), blueNum = blue_edges.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; redNum; ++i) &#123;            redAdj[red_edges[i][<span class="hljs-number">0</span>]].push_back(red_edges[i][<span class="hljs-number">1</span>]);            redVis[red_edges[i][<span class="hljs-number">0</span>]].push_back(<span class="hljs-literal">false</span>);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; blueNum; ++i) &#123;            blueAdj[blue_edges[i][<span class="hljs-number">0</span>]].push_back(blue_edges[i][<span class="hljs-number">1</span>]);            blueVis[blue_edges[i][<span class="hljs-number">0</span>]].push_back(<span class="hljs-literal">false</span>);        &#125;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, INT32_MAX)</span></span>;        <span class="hljs-built_in">queue</span>&lt;Node&gt; q;        q.push(Node(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));        q.push(Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!q.empty()) &#123;            Node u = q.front();            q.pop();            <span class="hljs-keyword">if</span> (u.color == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 若u由一条蓝边到，找从u出发的红边</span>                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nextRed = redAdj[u.vertex];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nextRed.<span class="hljs-built_in">size</span>(); ++i) &#123;                    <span class="hljs-keyword">int</span> v = nextRed[i];                    <span class="hljs-comment">// 若该边未访问过，将结点入队</span>                    <span class="hljs-keyword">if</span> (!redVis[u.vertex][i]) &#123;                        redVis[u.vertex][i] = <span class="hljs-literal">true</span>;                        q.push(Node(<span class="hljs-number">0</span>, v, u.len + <span class="hljs-number">1</span>));                        ans[v] = <span class="hljs-built_in">min</span>(ans[v], u.len + <span class="hljs-number">1</span>);                    &#125;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nextBlue = blueAdj[u.vertex];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nextBlue.<span class="hljs-built_in">size</span>(); ++i) &#123;                    <span class="hljs-keyword">int</span> v = nextBlue[i];                    <span class="hljs-keyword">if</span> (!blueVis[u.vertex][i]) &#123;                        blueVis[u.vertex][i] = <span class="hljs-literal">true</span>;                        q.push(Node(<span class="hljs-number">1</span>, v, u.len + <span class="hljs-number">1</span>));                        ans[v] = <span class="hljs-built_in">min</span>(ans[v], u.len + <span class="hljs-number">1</span>);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)            ans[i] = (ans[i] == INT32_MAX) ? <span class="hljs-number">-1</span> : ans[i];        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></li></ul></li><li><p><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">LeetCode-787. K 站中转内最便宜的航班</a></p> <pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span>    <span class="hljs-keyword">int</span> v;    <span class="hljs-keyword">int</span> w;    Edge(<span class="hljs-keyword">int</span> iv, <span class="hljs-keyword">int</span> iw) &#123;        v = iv;        w = iw;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>    <span class="hljs-keyword">int</span> v;    <span class="hljs-keyword">int</span> w;    <span class="hljs-keyword">int</span> k;    Node(<span class="hljs-keyword">int</span> iv, <span class="hljs-keyword">int</span> iw, <span class="hljs-keyword">int</span> ik) &#123;        v = iv, w = iw, k = ik;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;flights, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dst, <span class="hljs-keyword">int</span> K)</span> </span>&#123;        <span class="hljs-comment">// 初始化邻接表</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Edge&gt;&gt; <span class="hljs-title">adj</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;Edge&gt;())</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;edge:flights)            adj[edge[<span class="hljs-number">0</span>]].push_back(Edge(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]));        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, INT32_MAX)</span></span>;        res[src] = <span class="hljs-number">0</span>;        <span class="hljs-built_in">queue</span>&lt;Node&gt; q;        q.push(Node(src, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));        <span class="hljs-keyword">while</span> (!q.empty()) &#123;            Node t = q.front();            q.pop();            <span class="hljs-keyword">if</span> (t.k &gt; K + <span class="hljs-number">1</span>)                <span class="hljs-keyword">continue</span>;            <span class="hljs-built_in">vector</span>&lt;Edge&gt; next = adj[t.v];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;tmp : next) &#123;                <span class="hljs-keyword">int</span> w = tmp.w + t.w;                <span class="hljs-keyword">if</span> (w &lt; res[tmp.v]) &#123;                    res[tmp.v] = w;                    q.push(Node(tmp.v, w, t.k + <span class="hljs-number">1</span>));                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res[dst] == INT32_MAX ? <span class="hljs-number">-1</span> : res[dst];    &#125;&#125;;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>最短路径</tag>
      
      <tag>Dijsktra</tag>
      
      <tag>Floyd</tag>
      
      <tag>Bellman-Ford</tag>
      
      <tag>SPFA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows Terminal美化（配置Powershell7+PSReadLine+oh-my-posh）</title>
    <link href="/wt/"/>
    <url>/wt/</url>
    
    <content type="html"><![CDATA[<blockquote><p>好看是第一生产力。    — 鲁迅</p></blockquote><a id="more"></a><blockquote><p>最终效果如封面。</p></blockquote><h1 id="Windows-Terminal基础配置"><a href="#Windows-Terminal基础配置" class="headerlink" title="Windows Terminal基础配置"></a>Windows Terminal基础配置</h1><h2 id="Scoop安装"><a href="#Scoop安装" class="headerlink" title="Scoop安装"></a>Scoop安装</h2><p>Scoop是一款Windows下的包管理器，不是必须安装的，但是之后的部分配置我是用Scoop下载的。<br>Scoop的安装：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">set</span>-executionpolicy remotesigned -scope currentuser</span><span class="hljs-meta">$</span><span class="bash"> iex (new-object net.webclient).downloadstring(<span class="hljs-string">&#x27;https://get.scoop.sh&#x27;</span>)</span><span class="hljs-meta">#</span><span class="bash"> 测试是否安装成功：</span>scoop help</code></pre><h3 id="Scoop快速入门"><a href="#Scoop快速入门" class="headerlink" title="Scoop快速入门"></a>Scoop快速入门</h3><p>以安装Python为例：</p><ol><li>搜索软件包（会在你现在安装的仓库里搜索）：<code>scoop search python</code></li><li>安装：<code>scoop install python</code> （可以先使用<code>scoop info python</code>查看当前软件的详细信息看是不是你需要的）</li><li>提示安装成功后，可以通过 <code>scoop list</code> 查看当前安装的软件</li><li>卸载：<code>scoop uninstall python</code></li><li>更新：<code>scoop update python</code>（可以先通过<code>scoop status</code>查看当前是否有可更新的软件）。也可以使用命令 <code>scoop update *</code> 直接更新所有软件包括scoop自身。</li><li>清理历史版本软件包与缓存：<code>scoop cleanup *</code>。scoop更新软件后不会自动卸载旧版本的软件包，需要手动cleanup来清理。</li></ol><p>Scoop安装的软件存放路径：<code>C:\Users\用户名\scoop</code></p><h3 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h3><p>Scoop自带的官方仓库main的软件比较少，不太能满足我们的需求，但是它有一个bucket软件源策略，而且有社区来维护，常用软件基本能够找到。</p><p>bucket官方维护源包括：（输入命令<code> scoop bucket known</code> 可以查看）</p><pre><code class="hljs shell">scoop bucket add main # 默认scoop bucket add extras # 推荐scoop bucket add versions # 收录软件包的历史版本scoop bucket add nightliesscoop bucket add nirsoftscoop bucket add phpscoop bucket add nerd-fonts # 编程字体scoop bucket add nonportablescoop bucket add javascoop bucket add gamesscoop bucket add jetbrains # 推荐</code></pre><p>也可以添加第三方的，语法格式为：<code>scoop bucket add [仓库名] [仓库地址]</code></p><p>例如添加一个包括一些国内常用应用（微信、QQ、网易云音乐）的第三方库：<br><code>scoop bucket add dorado https://github.com/chawyehsu/dorado</code></p><p>移除仓库：<code>scoop rm php</code></p><h3 id="Scoop命令不完全指北"><a href="#Scoop命令不完全指北" class="headerlink" title="Scoop命令不完全指北"></a>Scoop命令不完全指北</h3><p><code>scoop help</code> 获取命令帮助列表<br><code>scoop install 软件名</code> 安装<br><code>scoop install 软件名@3.7.6</code> 安装指定版本<br><code>scoop install extras/sumatrapdf</code> 安装指定仓库内版本<br><code>scoop update 软件名</code> 更新<br><code>scoop update *</code> 更新Scoop、所有安装的软件<br><code>scoop cleanup *</code> 清理历史版本软件包与缓存<br><code>scoop uninstall 软件名</code> 卸载<br><code>scoop reset 软件名</code> 版本切换<br><code>scoop depends 软件名</code> 查看软件的依赖<br><code>scoop hold 软件名</code>  禁止软件更新<br><code>scoop unhold 软件名</code>  启动软件更新<br><code>scoop home 软件名</code>  打开软件主页<br><code>scoop info 软件名</code>  显示软件信息<br><code>scoop list</code>   列出所有已安装软件<br><code>scoop prefix 软件名</code>  查看软件路径<br><code>scoop reset 软件名</code>  恢复软件版本<br><code>scoop search 软件名</code>  搜索软件<br><code>scoop status 软件名</code>  查看软件更新状态</p><h3 id="gsudo安装"><a href="#gsudo安装" class="headerlink" title="gsudo安装"></a>gsudo安装</h3><p>gsudo解决了管理员权限问题，不需要再单独打开管理员权限的Powershell窗口。<br>安装：<code>scoop install gsudo</code><br>使用：在需要使用的命令前添加 <code>gsudo</code> 即可。（或者只输入命令<code>gsudo</code>，则直接进入管理员模式）</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>Windows Terminal下载：</p><ul><li>方式一：<a href="">Windows Terminal下载</a> </li><li>方式二：直接在 Microsoft Store 搜索下载</li><li>方式三：使用 Scoop 安装（通过 <a href="https://github.com/h404bi">@h404bi</a> 维护的第三方 bucket）<pre><code class="hljs shell">scoop bucket add dorado https://github.com/h404bi/doradoscoop install windowsterminal</code></pre><br></li></ul><p><a href="https://github.com/PowerShell/PowerShell/releases">PowerShell 7下载</a></p><h2 id="WT配置自定义"><a href="#WT配置自定义" class="headerlink" title="WT配置自定义"></a>WT配置自定义</h2><p>打开配置文件：</p><div align=center><img src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200819141247.png" width=60%></div><h3 id="自定义全局属性"><a href="#自定义全局属性" class="headerlink" title="自定义全局属性"></a>自定义全局属性</h3><p>位于配置文件最开始的位置，可修改的全部属性参考：<a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/global-settings">全局设置</a><br>我修改的配置：</p><ul><li>Terminal 亮暗主题：<code>&quot;theme&quot;: &quot;dark&quot;</code></li></ul><h3 id="自定义环境入口-添加新Shell"><a href="#自定义环境入口-添加新Shell" class="headerlink" title="自定义环境入口(添加新Shell)"></a>自定义环境入口(添加新Shell)</h3><p>Windows Terminal 下拉菜单中可选择的环境是能自由配置的，其中每个环境有可以单独设置字体，初始目录，配色方案，背景等等。</p><p>环境的配置位于<code>profiles[]</code>中：</p><div align=center><img src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200819144453.png" width=100%></div><p>一个典型的环境配置包括（以我配置的PowerShell7为例）：</p><pre><code class="hljs json">&#123;    <span class="hljs-comment">// 下拉菜单中显示的名字</span>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;PowerShell7&quot;</span>,    <span class="hljs-comment">// 下拉菜单中显示的icon</span>    <span class="hljs-comment">// 路径的语法格式可以用： </span>    <span class="hljs-comment">//      1. ms-appdata:///roaming/&#123;图片路径&#125;</span>    <span class="hljs-comment">//      2. 直接填图片路径 </span>    <span class="hljs-attr">&quot;icon&quot;</span>: <span class="hljs-string">&quot;ms-appdata:///roaming/E:\\保存图片\\icon\\cloudshell.png&quot;</span>,     <span class="hljs-comment">// 标识符，直接在PowerShell中输入命令 new-guid 就可以得到一个新的GUID</span>    <span class="hljs-comment">// 如果guid设置为和全局属性的&quot;defaultProfile&quot;一样的话，打开 WT 就会默认为这个环</span>    <span class="hljs-attr">&quot;guid&quot;</span>: <span class="hljs-string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span>,         <span class="hljs-comment">// 唤起环境时执行这一命令，我这里加了个参数不输出启动日志信息</span>    <span class="hljs-attr">&quot;commandline&quot;</span>: <span class="hljs-string">&quot;path\\pwsh.exe -nologo&quot;</span>,     <span class="hljs-comment">// 唤起环境时所处的起始目录</span>    <span class="hljs-attr">&quot;startingDirectory&quot;</span>: <span class="hljs-string">&quot;path\\...&quot;</span>,     <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#fa9395&quot;</span>, <span class="hljs-comment">// 光标的颜色</span>    <span class="hljs-attr">&quot;cursorShape&quot;</span>: <span class="hljs-string">&quot;vintage&quot;</span>, <span class="hljs-comment">// 光标的形状。包括：bar、empytBox、filledBox、vintage</span>    <span class="hljs-attr">&quot;colorScheme&quot;</span>: <span class="hljs-string">&quot;Chalkboard&quot;</span>, <span class="hljs-comment">// 配色方案，除了几个默认的还可以在下面的&quot;schemes&quot;: []中定义</span>    <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#2a2a2a&quot;</span>, <span class="hljs-comment">// 背景色</span>    <span class="hljs-attr">&quot;useAcrylic&quot;</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开启毛玻璃特效</span>    <span class="hljs-attr">&quot;acrylicOpacity&quot;</span>: <span class="hljs-number">0.3</span>, <span class="hljs-comment">// 毛玻璃特效的不透明度</span>    <span class="hljs-attr">&quot;backgroundImage&quot;</span>: <span class="hljs-string">&quot;path\\IMG_111.jpg&quot;</span>, <span class="hljs-comment">// 背景图片</span>    <span class="hljs-attr">&quot;backgroundImageOpacity&quot;</span>: <span class="hljs-number">0.5</span> <span class="hljs-comment">// 背景图片的不透明度</span>&#125;</code></pre><p>更多详细配置参考：<a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/profile-settings">配置文件设置</a></p><h3 id="添加自定义配色方案"><a href="#添加自定义配色方案" class="headerlink" title="添加自定义配色方案"></a>添加自定义配色方案</h3><p>一个可以预览Windows Terminal主题并一键复制json文件的网站：<a href="https://atomcorp.github.io/themes/">Windows Terminal Themes</a></p><div align=center><img src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200819150228.png" width=100%></div><p>点击下面的<code>Get theme</code>即将json文件复制到剪切板。e.g.</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Andromeda&quot;</span>,  <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#000000&quot;</span>,  <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#cd3131&quot;</span>,  <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#05bc79&quot;</span>,  <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#e5e512&quot;</span>,  <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#2472c8&quot;</span>,  <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#bc3fbc&quot;</span>,  <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#0fa8cd&quot;</span>,  <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#e5e5e5&quot;</span>,  <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#666666&quot;</span>,  <span class="hljs-comment">//命令行参数</span>  <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#cd3131&quot;</span>,  <span class="hljs-comment">//错误信息</span>  <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#05bc79&quot;</span>,  <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#e5e512&quot;</span>,  <span class="hljs-comment">//命令</span>  <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#2472c8&quot;</span>,  <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#bc3fbc&quot;</span>,  <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#0fa8cd&quot;</span>,  <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#e5e5e5&quot;</span>,  <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#262a33&quot;</span>,  <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#e5e5e5&quot;</span>&#125;</code></pre><p>我标识了几个颜色代表的参数，都不喜欢也可以自己DIY。</p><h3 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h3><p>在<code>&quot;keybindings&quot;: []</code>进行设置。默认的包括：</p><ul><li><code>Ctrl</code> + <code>Shift</code> + <code>F</code>：全局查找</li><li><code>Ctrl</code> + <code>Shift</code> + <code>T</code>：打开新标签页</li><li><code>Ctrl</code> + <code>Shift</code> + <code>1/2/3...</code>：进入配置文件中定义的第一/二/三/…个环境</li><li><code>Ctrl</code> + <code>Tab</code>：前一个标签页</li><li><code>Ctrl</code> + <code>Shift</code> + <code>Tab</code>：后一个标签页</li><li><code>Alt</code> + <code>Shift</code> + <code>-</code>：横向分屏</li><li><code>Alt</code> + <code>Shift</code> + <code>+</code>：纵向分屏</li><li><code>Ctrl</code> + <code>+</code>：放大</li><li><code>Ctrl</code> + <code>-</code>：缩小</li><li><code>Ctrl</code> + <code>0</code>：恢复默认缩放比例</li></ul><p>更多详细配置参考：<a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/key-bindings">自定义键绑定</a></p><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="oh-my-posh安装和配置"><a href="#oh-my-posh安装和配置" class="headerlink" title="oh-my-posh安装和配置"></a>oh-my-posh安装和配置</h2><p>打开管理员权限的Powershell窗口（安装了gsudo的可以在命令前面直接加上<code>gsudo</code>）：</p><pre><code class="hljs shell">Install-Module posh-git # 如果你的电脑里没有安装Git，输入这行会报错，解决方法是安装Git或者把这一行去掉。Install-Module oh-my-poshSet-Theme Agnoster # 这个是设置主题，你也可以选其他的，通过命令Get-Theme命令来查看其他主题</code></pre><p>上面的导入只对当前窗口有效，所以需要将其添加到配置文件中：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-keyword">if</span> (!(Test-Path -Path <span class="hljs-variable">$PROFILE</span> )) &#123; New-Item -Type File -Path <span class="hljs-variable">$PROFILE</span> -Force &#125; notepad <span class="hljs-variable">$PROFILE</span></span><span class="hljs-meta">#</span><span class="bash"> 该命令打开默认 PowerShell 的启动配置文件（如果没有就创建），notepad表示用记事本打开，如果你安装了vscode，也可以替换成 code</span><span class="hljs-meta">#</span><span class="bash"> 已经存在启动配置文件的话可以直接用命令 notepad/code <span class="hljs-variable">$PROFILE</span> 打开</span></code></pre><p>然后把前面三行内容复制到 Microsoft.PowerShell_profile.ps1 文件中。<br>重新打开窗口或者输入命令<code>.$Profile</code>让配置文件生效。</p><blockquote><p>oh-my-posh只支持部分字体，可以使用我目前用的这款：<a href="https://github.com/tonsky/FiraCode/releases">Fira Code</a></p></blockquote><h3 id="隐藏主机名"><a href="#隐藏主机名" class="headerlink" title="隐藏主机名"></a>隐藏主机名</h3><blockquote><p>个人觉得命令行前面显示的一长串太难看了。</p></blockquote><ol><li><p>找到oh-my-posh的主题文件夹。</p><ul><li>如果你安装有everything可以直接搜索Agnoster或者任意主题名字试试。</li><li>没有的话应该在这个路径下：<code>C:\Users\你的用户名\Documents\PowerShell\Modules\oh-my-posh\2.0.465\Themes</code></li></ul></li><li><p>打开对应主题的.psm1文件，比如我使用的 Agnoster.psm1，搜索 <code>$user@$computer</code> 定位到如下内容，直接将整个 if语句 注释掉。</p> <div align=center><img src="https://gitee.com/Drrany/picbed/raw/master/images_blog/20200819195157.png" width=100%></div></li></ol><h2 id="PSReadLine安装和配置"><a href="#PSReadLine安装和配置" class="headerlink" title="PSReadLine安装和配置"></a>PSReadLine安装和配置</h2><blockquote><p>PSReadLine 是一个由微软发布的用于 PowerShell 的行读取实现，提供了以下功能：</p><ul><li>语法着色</li><li>简单语法错误通知</li><li>良好的多行体验</li><li>可自定义的键绑定</li><li>Cmd和Emacs模式</li><li>许多配置选项</li><li>Bash 样式的补全</li><li>Bash/zsh 样式的交互式历史记录搜索</li><li>Emacs yank/kill ring</li><li>基于 PowerShell Token 的单词移动和删除</li><li>撤销/重做</li><li>自动保存历史记录，包括在实时会话中共享历史记录</li><li>菜单补全、Intellisense</li></ul></blockquote><p><strong>安装</strong>：<code>$ Install-Module -Name PSReadLine -AllowPrerelease -Force</code><br><strong>打开配置文件</strong>：<code>code $PROFILE</code><br>在里面添加以下内容：</p><pre><code class="hljs sql"><span class="hljs-keyword">Set</span>-PSReadLineOption -PredictionSource History <span class="hljs-comment"># 设置预测文本来源为历史记录</span> <span class="hljs-keyword">Set</span>-PSReadlineKeyHandler -<span class="hljs-keyword">Key</span> Tab -<span class="hljs-keyword">Function</span> <span class="hljs-keyword">Complete</span> <span class="hljs-comment"># 设置 Tab 键补全</span><span class="hljs-keyword">Set</span>-PSReadLineKeyHandler -<span class="hljs-keyword">Key</span> <span class="hljs-string">&quot;Ctrl+d&quot;</span> -<span class="hljs-keyword">Function</span> MenuComplete <span class="hljs-comment"># 设置 Ctrl+d 为菜单补全和 Intellisense</span><span class="hljs-keyword">Set</span>-PSReadLineKeyHandler -<span class="hljs-keyword">Key</span> <span class="hljs-string">&quot;Ctrl+z&quot;</span> -<span class="hljs-keyword">Function</span> <span class="hljs-keyword">Undo</span> <span class="hljs-comment"># 设置 Ctrl+z 为撤销</span><span class="hljs-keyword">Set</span>-PSReadLineKeyHandler -<span class="hljs-keyword">Key</span> UpArrow -<span class="hljs-keyword">Function</span> HistorySearchBackward <span class="hljs-comment"># 设置向上键为后向搜索历史记录</span><span class="hljs-keyword">Set</span>-PSReadLineKeyHandler -<span class="hljs-keyword">Key</span> DownArrow -<span class="hljs-keyword">Function</span> HistorySearchForward <span class="hljs-comment"># 设置向下键为前向搜索历史纪录</span></code></pre><p><a href="https://github.com/PowerShell/PSReadLine">PSReadLine更多配置参考</a></p><h2 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h2><p>经常使用Git，所以想设置一些简短点的别名。<br>powershell的别名不支持语句，只能用命令所以这里还是搞了蛮久的。<br>需要用函数来帮忙，举个🌰 ：假如我想设置<code>git commit -m</code> -&gt; <code>cm</code>。因为后面肯定是有个字符串参数的，所以在配置文件里要这么写：</p><pre><code class="hljs ps1"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCommit</span><span class="hljs-params">()</span></span> &#123;      git commit <span class="hljs-literal">-m</span> <span class="hljs-variable">$args</span>&#125;<span class="hljs-built_in">Set-Alias</span> cm getCommit</code></pre><p>另外这个函数名<code>getCommit</code>是不能随便起的，有一定的规范，按我这种写应该是没问题的。<br>如果是不带参数的命令，就可以去掉<code>$args</code>。<br><a href="https://www.pstips.net/powershell-alias.html">Powershell 别名详细参考</a></p><br><br><hr><p>参考网址：<br><a href="https://sspai.com/post/59380">https://sspai.com/post/59380</a><br><a href="https://docs.microsoft.com/zh-cn/windows/terminal/">https://docs.microsoft.com/zh-cn/windows/terminal/</a><br><a href="https://segmentfault.com/a/1190000023337501">https://segmentfault.com/a/1190000023337501</a><br><a href="https://zhuanlan.zhihu.com/p/137251716">https://zhuanlan.zhihu.com/p/137251716</a><br><a href="https://printempw.github.io/windows-terminal-setup-guide/#3-2-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE">https://printempw.github.io/windows-terminal-setup-guide/#3-2-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE</a></p>]]></content>
    
    
    <categories>
      
      <category>配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GithubPages+Hexo搭建个人博客记录</title>
    <link href="/GithubPages+Hexo/"/>
    <url>/GithubPages+Hexo/</url>
    
    <content type="html"><![CDATA[<p>记录一下简单流程和出现的问题。</p><a id="more"></a><blockquote><p>本文基本上是一个基本步骤的记录，没有太多的讲解，如果希望了解更多原理性知识，推荐阅读文章末尾的链接。</p><p>提示：部分网上很多的安装教程基本都进行了简略，以后闲的话可能会补一下（flag插好_(:з」∠)_）</p></blockquote><h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><p>首先明确需求：</p><ul><li><p>服务器：GitHub Pages</p></li><li><p>博客框架：Hexo</p></li></ul><p>因此要做的准备有如下：</p><h2 id="1-准备GitHub-Pages"><a href="#1-准备GitHub-Pages" class="headerlink" title="1. 准备GitHub Pages"></a>1. 准备GitHub Pages</h2><ol><li>安装 <a href="https://git-scm.com/">git</a><br> 通过  <code>$ git --version</code> 测试是否安装成功。</li><li>注册GitHub账户并配置SSH key</li><li>在GitHub上开启GitHub pages服务（其实就是创建一个仓库，仓库的名字必须是 username.github.io）<br>到这步可以测试一下：在浏览器输入 <code>https://username.github.io</code> 能否访问成功</li></ol><h2 id="2-准备Hexo"><a href="#2-准备Hexo" class="headerlink" title="2. 准备Hexo"></a>2. 准备Hexo</h2><ol><li><p>安装 <a href="https://nodejs.org/en/">node.js</a><br>通过 <code>$ node --version</code> 测试是否安装成功。</p></li><li><p>通过<code>npm</code>安装 <code>Hexo</code>，终端输入命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -g hexo-cli</span></code></pre></li><li><p>创建站点根目录（站点根目录中的文件就是我们博客所需的资源）：<br>Hexo会在指定的这个站点根目录中创建所需要的文件</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> hexo init &lt;指定目录&gt;</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> &lt;指定目录&gt;</span><span class="hljs-meta">$</span><span class="bash"> npm install</span></code></pre></li><li><p>预览博客：输入 <code>$ hexo server</code> 。浏览器访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 即可看到当前根目录对应的博客资源</p></li><li><p>根据站点根目录内容生成静态文件：输入 <code>$ hexo generate</code>。生成的文件位于 <code>/public/</code> 文件夹中，下一步就需要将生成的静态文件上传到GitHub仓库中</p></li></ol><h3 id="2-1-站点目录结构分析"><a href="#2-1-站点目录结构分析" class="headerlink" title="2.1 站点目录结构分析"></a>2.1 站点目录结构分析</h3><ul><li><p><code>.deploy_git</code>：<code>hexo g</code> 生成</p></li><li><p><code>node_modules/</code>：安装包的目录，执行 <code>npm install</code> 的时候会重新生成</p></li><li><p><code>scaffolds/</code>：文章的布局</p><ul><li><p>当创建新的文章时，Hexo会根据scaffold里的不同布局来建立文件，默认布局由 <code>_config.yml</code> 中的 <code>default_layout</code> 参数指定。</p></li><li><p>不同布局创建的文章保存路径有所区别：</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td><code>source/_post</code></td></tr><tr><td>page</td><td><code>source/</code></td></tr><tr><td>draft</td><td><code>source/_draft</code></td></tr><tr><td>自定义</td><td><code>source/_post</code></td></tr></tbody></table></li></ul></li><li><p><code>source</code>：博客文章的.md文件。除<code>\_post</code>文件夹外，开头以<code>_</code>（下划线）命名的文件/文件夹或隐藏文件都会在generate时被忽略。</p></li><li><p><code>themes/</code>：主题文件夹</p></li><li><p><code>.gitignore</code>：限定在push时哪些文件可以忽略</p></li><li><p><code>_config.yml</code>：站点的配置文件。配置参数参考：<a href="https://hexo.io/zh-cn/docs/configuration">Hexo配置参数说明</a></p></li><li><p><code>db.json</code>：<code>hexo g</code> 生成的文件</p></li><li><p><code>package.json</code>：应用程序信息，包括hexo的版本信息和所有安装的依赖</p></li><li><p><code>.git/</code>：标志这是一个git项目</p></li><li><p><code>public</code>：<code>hexo g</code> 生成的静态网页</p></li></ul><blockquote><p>总结下，需要备份的文件有：<code>scaffolds/</code>、<code>source</code>、<code>themes/</code>、<code>_config.yml</code>、<code>package.json</code>、<code>.gitignore</code></p></blockquote><h3 id="2-2-Hexo指令参考"><a href="#2-2-Hexo指令参考" class="headerlink" title="2.2 Hexo指令参考"></a>2.2 Hexo指令参考</h3><p><code>$ hexo init [folder]</code></p><ul><li>新建一个网站根目录，进行初始化。</li></ul><p><code>$ hexo clean</code></p><ul><li>清除缓存文件 (db.json) 和已生成的静态文件 (public)。如果发现对站点的更改无法生效，可能需要运行该命令。</li></ul><p><code>$ hexo new [layout] &lt;title&gt;</code></p><ul><li>新建一篇文章，标题含有空格的话需要用单/双引号括起来。</li><li>layout：文章布局。默认由 _config.yml 中的 default_layout 参数指定</li><li>参数：<ul><li>-p, –path        自定义新文章的路径（默认情况下会解析标题来确定路径）</li><li>-r, –replace    如果存在同名文章，将其替换</li><li>-s, –slug        文章的 Slug，作为新文章的文件名和发布后的 URL</li></ul></li></ul><p><code>$ hexo generate/g</code></p><ul><li><p>生成静态文件。（将souce文件夹下的Markdown和HTML文件解析到了public文件夹下）</p></li><li><p>参数：</p><ul><li><p>-d, –deploy    文件生成后立即部署网站</p></li><li><p>-w, –watch        监视文件变动</p></li><li><p>-b, –bail        生成过程中如果发生任何未处理的异常则抛出异常</p></li><li><p>-f, –force        强制重新生成文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</p></li><li><p>-c, –concurrency    最大同时生成文件的数量，默认无限制</p></li></ul></li></ul><p><code>$ hexo publish [layout] &lt;filename&gt;</code></p><ul><li>发表草稿。草稿默认不会显示在页面中。</li></ul><p><code>$ hexo server/s</code></p><ul><li><p>启动服务器。默认情况下，访问网址为：<a href="http://localhost:4000/">http://localhost:4000/</a></p></li><li><p>参数：</p><ul><li>-p, –port    重设端口</li><li>-s, –static    只使用静态文件</li><li>-l, –log    启动日记记录，使用覆盖记录格式</li></ul></li></ul><p><code>$ hexo deploy/d</code></p><ul><li>部署网站。（将本地资源部署到服务器，我这里也就是GithubPages中）</li><li>参数：-g, –generate    部署之前预先生成静态文件</li></ul><p><code>$ hexo render &lt;file1&gt; [file2] ...</code></p><ul><li>渲染文件。</li><li>参数：-o, –output    设置输出路径</li></ul><p><code>$ hexo migrate &lt;type&gt;</code></p><ul><li>从其他博客系统迁移内容。可从RSS、Jekyll、Octopress、WordPress、Joomla中迁移，具体参考 <a href="https://hexo.io/zh-cn/docs/migration">博客迁移</a></li></ul><p><strong>选项：</strong></p><p><code>$ hexo --safe</code></p><ul><li>安全模式。不会载入插件和脚本。在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</li></ul><p><code>$ hexo --debug</code></p><ul><li>调试模式。在终端中显示调试信息并记录到 debug.log。</li></ul><p><code>$ hexo --silent</code></p><ul><li>简洁模式。隐藏终端信息。</li></ul><p><code>$ hexo --draft</code></p><ul><li>显示 source/_drafts 文件夹中的草稿文章。</li></ul><p><code>$ hexo --cwd /path/to/cwd</code></p><ul><li>自定义当前工作目录（Current working directory）的路径。</li></ul><h2 id="3-将静态文件部署到对应的仓库中"><a href="#3-将静态文件部署到对应的仓库中" class="headerlink" title="3. 将静态文件部署到对应的仓库中"></a>3. 将静态文件部署到对应的仓库中</h2><ol><li><p>打开站点根目录中的 <code>_config.yml</code> 文件，找到deploy字段（在最下面），将其用以下内容替换：</p><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:username/username.github.io.git</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></li><li><p>安装插件（注意要在站点根目录下执行该操作）：<code>$ npm install hexo-deployer-git --save</code></p></li><li><p>部署： <code>$ hexo deploy</code>（建议执行该步前先 <code>$ hexo clean</code>）</p></li></ol><br><hr><h1 id="二、内容管理"><a href="#二、内容管理" class="headerlink" title="二、内容管理"></a>二、内容管理</h1><blockquote><p>博客发布的内容都位于 <code>source/_post/</code> 文件夹中。</p></blockquote><ol><li>创建新文章：<code>$ hexo new &#39;title&#39;</code></li><li>创建成功后会发现 <code>source/_post/</code> 中多了一篇相同标题的<code>.md</code>文件，打开该文件编辑即可</li><li>编辑完成发布：<code>$ hexo g -d</code></li></ol><p>也可以在<code>source/_post/</code>目录下手动创建<code>.md</code>文件，但这时就需要你自己手动复制一下poster：</p><pre><code class="hljs html">---title: date: tags: categories: ---</code></pre><p>删除文件则直接在文件夹内手动删除然后重新部署就好了。</p><br><hr><h1 id="三、主题修改"><a href="#三、主题修改" class="headerlink" title="三、主题修改"></a>三、主题修改</h1><blockquote><p>我本人使用的是 landscape 主题，不过你可以挑选任何你喜欢的主题<a href="https://hexo.io/themes/">主题商城</a>，我这里建议使用 NexT 主题，因为它的各方面插件都比较完善不需要费太多时间。</p></blockquote><p>修改主题步骤：</p><ol><li>下载主题文件夹到/themes/目录下</li><li>修改站点配置文件中的theme字段，e.g.  <pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">landscape</span></code></pre></li></ol><hr><h1 id="四、检索配置"><a href="#四、检索配置" class="headerlink" title="四、检索配置"></a>四、检索配置</h1><h2 id="1-配置sitemap文件"><a href="#1-配置sitemap文件" class="headerlink" title="1. 配置sitemap文件"></a>1. 配置sitemap文件</h2><ol><li><p>在站点根目录下输入以下命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install hexo-generator-sitemap —save</span><span class="hljs-meta">$</span><span class="bash"> npm install hexo-generator-baidu-sitemap —save </span></code></pre></li><li><p>在站点根目录的配置文件_cpnfig.yml中添加：</p><pre><code class="hljs yaml"><span class="hljs-comment"># sitemap</span><span class="hljs-attr">sitemap:</span>  <span class="hljs-attr">path:</span> <span class="hljs-string">sitemap.xml</span><span class="hljs-attr">baidusitemap:</span>  <span class="hljs-attr">path:</span> <span class="hljs-string">baidusitemap.xml</span></code></pre></li><li><p>执行：<code>$ hexo g</code><br>public文件夹下多了 <strong>sitemap.xml</strong> 和 <strong>baidusitemap.xml</strong> 两个文件，这就是供搜索Google和百度引擎爬虫抓取的站点地图。</p></li></ol><h2 id="2-Google站点验证"><a href="#2-Google站点验证" class="headerlink" title="2. Google站点验证"></a>2. Google站点验证</h2><ol><li>进入 <a href="https://www.google.com/webmasters/tools/">Google站点管理工具</a> ，选择网址前缀，在网址中输入你的博客地址。</li><li>下载HTML文件，将文件放到站点根目录下的 <code>/public</code> 文件夹中</li><li>执行 <code>$ hexo d</code></li><li>等待一分钟左右，返回Google页面点击验证</li><li>验证成功后再次回到  <a href="https://www.google.com/webmasters/tools/">Google站点管理工具</a>  。在右侧工具栏中找到 <strong>站点地图</strong> 选项。</li><li>在界面中输入 <strong>sitemap的存放路径</strong>。因为public为站点的实际根目录，所以输入的是 <code>sitemap.xml</code></li><li>等待一段时间即可通过Google检索到</li></ol><blockquote><p>注意这里Google会先显示站点地图无法获取，但其实后台已经在处理了，大概等1~2天就能检索到。</p></blockquote><h2 id="3-百度站点验证"><a href="#3-百度站点验证" class="headerlink" title="3. 百度站点验证"></a>3. 百度站点验证</h2><p>参考：<a href="https://www.cnblogs.com/lfri/p/12219639.html">https://www.cnblogs.com/lfri/p/12219639.html</a></p><br><hr><h1 id="五、遇到的问题＆总结"><a href="#五、遇到的问题＆总结" class="headerlink" title="五、遇到的问题＆总结"></a>五、遇到的问题＆总结</h1><ol><li>频繁在修改网站资源需要预览时使用 <code>hexo s</code> 先在本地调试，直接部署的话太慢了，刷新记得 <code>ctrl+F5</code></li><li>如果用vscode编辑配置文件，要进行部署的时候记得在vscode把文件先关闭，不然会报错</li></ol><br><br><br><hr><blockquote><p>参考链接：</p><p><a href="https://sketchk.xyz/2017/03/24/A-Guide-Of-Making-Your-Personal-Blog-Part-1/">https://sketchk.xyz/2017/03/24/A-Guide-Of-Making-Your-Personal-Blog-Part-1/</a></p><p><a href="https://juejin.im/post/6844904131266609165#heading-18">https://juejin.im/post/6844904131266609165#heading-18</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
